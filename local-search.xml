<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2025/03/01/Redis/"/>
    <url>/2025/03/01/Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>实现方式：</p><ul><li>AOF日志：Append Only File，执行一条写一条日志。所以是在写完日志之后，记录做过的事。AOF丢失少，恢复慢。</li><li>RDB快照：全量快照，影响性能。</li><li>混合方式：RDB负责前半全量数据，减少能耗、快速恢复。AOF负责后半增量数据。</li></ul><h3 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h3><p><em>由于网络问题产生多个Leader</em>，旧Leader写入数据被新Leader的同步清除了</p><p><strong>解决方案</strong></p><p>在可能发生故障时限制写入</p><p>节点数量&lt;N 或 通信时长&gt;T</p><h4 id="Extra-Money"><a href="#Extra-Money" class="headerlink" title="Extra Money"></a>Extra Money</h4><p><strong>跳表</strong></p><p>​很好地解释了什么是跳表，一个每次跳跃2^n的二维数组<img src="https://picx.zhimg.com/v2-be424e42c99fde208c835d565499c3d7_1440w.jpg" alt="img"></p><p>和平衡二叉树不同的是，跳表使用概率达成均衡。每个节点有1&#x2F;skip的概率添加至上一层。</p><p><strong>RedBlack Tree</strong></p><p><em>为什么Redis使用跳表而不是红黑树？</em></p><ul><li>实现难度，维护成本</li><li>查询高效</li><li>并发扩展</li><li>概率平衡&#x2F;严格平衡</li></ul><h2 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h2><p><strong>过期字典</strong>：给设置过期时间的Key放在里面，查询时优先查找Expire Dict，比对过期时间</p><p><strong>惰性删除+定期删除</strong></p><p>​访问时过期才删除</p><p>​随机抽取，看看过期的占比。如果占比过多则重复删除。否则仅删除一轮</p><p><strong>RDB淘汰策略</strong></p><ul><li>新的RDB文件生成时会淘汰</li><li>主服务器淘汰。从服务器不主动淘汰，除非主服务器同步清除（DEL指令）</li></ul><p><strong>AOF淘汰策略</strong></p><ul><li>写入时保留过期键，等其被删除再追加DEL指令</li><li>重写时淘汰过期键</li></ul><p><strong>LRU LFU</strong></p><h2 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h2><h3 id="缓存保护"><a href="#缓存保护" class="headerlink" title="缓存保护"></a>缓存保护</h3><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a><strong>缓存雪崩</strong></h4><p>缓存雪崩是指在某一时间段内，大量缓存数据<strong>同时失效</strong>或<strong>缓存系统宕机</strong>，导致所有请求直接涌向数据库，造成数据库瞬时压力激增甚至崩溃的现象。</p><p><strong>解决方案</strong></p><ol><li><strong>失效时间随机化</strong>：在基础过期时间上增加随机偏移值（如：基础300秒±随机120秒）</li><li><strong>分级缓存架构</strong>：采用L1&#x2F;L2缓存分级，L1设置短时间，L2设置长时间</li><li><strong>热点数据永不过期</strong>：配合异步更新机制维护数据一致性</li><li><strong>熔断降级机制</strong>：使用Hystrix或Sentinel实现请求限流</li><li><strong>集群高可用</strong>：Redis Cluster模式部署，保证单节点故障不影响整体服务</li></ol><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a><strong>缓存击穿</strong></h4><p>某个超高热点的缓存突然失效，导致<strong>海量请求直接冲击数据库</strong>，形成”单点爆破”效应。</p><p><strong>解决方案</strong></p><ul><li><p><strong>互斥锁（Mutex Lock）</strong>：仅允许一个线程通过查询重建缓存，其他线程等待后重试。</p><p><em>互斥锁仅针对数据库请求</em></p></li><li><p><strong>逻辑过期</strong>：缓存永不过期，但存储逻辑过期时间，由后台线程异步更新。</p></li><li><p><strong>缓存预热</strong>：在高峰前预先加载热点数据。</p></li></ul><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a><strong>缓存穿透</strong></h4><p>大量请求查询<strong>数据库中不存在的数据</strong>，导致缓存无法命中，请求直接穿透到数据库。</p><p><strong>解决方案</strong></p><ul><li><strong>空值缓存</strong>：对查询结果为null的键，缓存短TTL的空值（如 <code>redis.set(key, null, 60)</code>）。</li><li><strong>布隆过滤器（Bloom Filter）</strong>：在缓存层前加过滤器，快速拦截无效请求。</li><li><strong>参数校验</strong>：对请求参数进行格式、范围校验（如ID必须为正整数）。</li></ul><h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><ul><li><p>Catch Aside：优先改变数据库，然后更新缓存</p><p><em><strong>为什么先数据库后缓存？</strong></em></p><p>源数据不更改，缓存始终跟着走。而且更新缓存比数据库快多了</p></li><li><p>R&#x2F;W Through：仅和缓存交互。其余交给缓存组件（不常见）</p></li><li><p>Write Back：批量异步更新脏缓存，写得快，容易丢数据</p></li></ul><h2 id="实战！！！"><a href="#实战！！！" class="headerlink" title="实战！！！"></a>实战！！！</h2><h3 id="大Key问题"><a href="#大Key问题" class="headerlink" title="大Key问题"></a>大Key问题</h3><p><strong>Key的Value很大</strong></p><ul><li>客户端超时</li><li>网络阻塞</li><li>工作线程阻塞</li><li>内存分布不均</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库的锁</title>
    <link href="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%94%81/"/>
    <url>/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>让数据库变成read only</p><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><ol><li>表锁：给表加锁，同时本线程无法访问其他表</li><li>元数据锁：对表操作隐式使用</li><li>意向锁：行级锁之前，快速判断有无记录被加锁</li><li>AUTO-INC锁：用于自增类型的加锁，不然容易出错</li></ol><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><ol><li>Record Lock：锁记录</li><li>Gap Lock：锁范围（开区间）。间隙锁之间是兼容的的，可以由多个事务持有重复区间的间隙锁。</li><li>Next-Key Lock：记录锁+间隙锁（一开一闭）。既保护了当前记录，又阻止间隙之间有新值插入。</li><li>插入意向锁：用于插入时占用锁等待队列。</li></ol><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>一致性，有效性，防止脑裂-&gt;过半节点同意。</p><h3 id="基于Redis"><a href="#基于Redis" class="headerlink" title="基于Redis"></a>基于Redis</h3><p>设置一个公共的Key和对应过期时间。Key&#x3D;0可以获得锁，否则不行。</p><h2 id="加锁时机"><a href="#加锁时机" class="headerlink" title="加锁时机"></a>加锁时机</h2><p>select update…</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>两个事务获得了公共的间隙锁，但是插入意向锁和对方的间隙锁起了冲突。</p><p><strong>解决方案</strong></p><ol><li>降低隔离级别，RC就不会使用gap lock</li><li>使用唯一索引，避免全表扫描…</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>分布式系统</tag>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四种隔离级别的思考</title>
    <link href="/2025/02/26/Txn/"/>
    <url>/2025/02/26/Txn/</url>
    
    <content type="html"><![CDATA[<h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>整体分为：</p><ol><li>读未提交</li><li>读已提交</li><li>可重复读</li><li>串行化</li></ol><h2 id="可能产生的问题"><a href="#可能产生的问题" class="headerlink" title="可能产生的问题"></a>可能产生的问题</h2><ol><li>脏读：读到其他事务未提交的数据，容易理解</li><li>不可重复读：多次读同一行内容不一致</li><li>幻读：多次读某个范围的数据，范围不一致（有插入删除）</li></ol><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>脏读和不可重复度：脏读可以认为事务B单次读取数据，读到事务A修改但未提交的数据。不可重复读可以看作事务B在事务A修改前后分别读了一次，得到的数据自然不同。</p><p>不可重复读和幻读：不可重复读按照上述，主要冲突在一次事务内读同一行两次数据不同。幻读可以认为是事务B读取某一范围的数据，而事务A在B的两次读取之间对该范围插入或删除了数据。产生一次读2条，第二次读3条的错误。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>通过产生的原因可以想到对应解决办法</p><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>通过MVCC（读快照），避免读到其他事务做出的修改。</p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>MVCC给每个事务生成最新快照，避免事务之间互相影响。</p><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>MVCC无法拦住边读边写的幻读。当数据出现更新，会悄悄把更新数据加进来。因此需要间隙锁或临键锁。</p><ol><li>间隙锁：范围锁，比如查询age&gt;20，会锁住(20,+inf)阻隔新数据加入&#x2F;旧数据修改。</li><li>临键锁：范围+当前键，比如age&gt;20，可以得到[20,+inf)</li></ol><h2 id="为什么有四种"><a href="#为什么有四种" class="headerlink" title="为什么有四种"></a>为什么有四种</h2><p><strong>为什么有四种隔离级别？既然低级别会产生错误，直接上高级别一刀切不就好了？</strong></p><p>数据库性能与一致性的互相妥协。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>raft</title>
    <link href="/2025/02/24/raft/"/>
    <url>/2025/02/24/raft/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>这是一个测试</title>
    <link href="/2025/02/24/%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95/"/>
    <url>/2025/02/24/%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="这是一个测试"><a href="#这是一个测试" class="headerlink" title="这是一个测试"></a>这是一个测试</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="标题1"><a href="#标题1" class="headerlink" title="标题1"></a>标题1</h2><h3 id="标题2"><a href="#标题2" class="headerlink" title="标题2"></a>标题2</h3>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>测试1</tag>
      
      <tag>测试2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试</title>
    <link href="/2025/02/24/%E6%B5%8B%E8%AF%95/"/>
    <url>/2025/02/24/%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/02/24/hello-world/"/>
    <url>/2025/02/24/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
