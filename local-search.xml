<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>PotatOS设计文档</title>
    <link href="/2025/06/15/PotatOS%E6%9E%B6%E6%9E%84/"/>
    <url>/2025/06/15/PotatOS%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="PotatOS🥔"><a href="#PotatOS🥔" class="headerlink" title="PotatOS🥔"></a>PotatOS🥔</h1><p>[toc]</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><h3 id="🥔什么是PotatOS"><a href="#🥔什么是PotatOS" class="headerlink" title="🥔什么是PotatOS"></a>🥔什么是PotatOS</h3><p>PotatOS是一个用 Rust 编写的基于 <a href="https://github.com/bosswnx/2024s-rcore-bosswnx">2024 春夏季开源操作系统训练营 rCore 项目</a>的 RISC-V 架构的兼容 POSIX 协议的操作系统内核，实现了基本的进程管理、内存管理、文件系统和设备驱动。</p><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><ul><li>主机：x86_64 Ubuntu 22.04 LTS</li><li>工具链：Rust (nightly) + riscv64gc-unknown-elf-gcc</li><li>调试：QEMU + GDB + VSCode (rust-analyzer)</li></ul><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">.<br>├── bootloader<br>├── easy-fs<br>├── easy-fs-fuse<br>├── Makefile<br>├── os<br>├── qemu-7.0.0<br>├── rust-toolchain.toml<br>├── setenv.sh<br>└── user<br></code></pre></td></tr></table></figure><ul><li><strong>bootloader</strong>：Qemu 模拟器启动时的引导加载程序。它负责在系统启动时初始化硬件，并将控制权交给操作系统内核。</li><li><strong>easy-fs</strong>：easy file system，是本系统采用的简化文件系统，负责文件的存储和管理。</li><li><strong>easy-fs-fuse</strong>：efs filesystem in userspace，用于测试 efs，并且能够把内核开发的应用打包成一个 efs 格式的文件系统镜像，方便在模拟器中使用。</li><li><strong>Makefile</strong>：包含了一系列编译和运行的规则，通过<code>make</code>命令可以方便地编译和运行操作系统。</li><li><strong>os</strong>：内核文件夹，存放操作系统内核的源代码。</li><li><strong>qemu-7.0.0</strong>：Qemu 文件夹，包含了 Qemu 模拟器的相关文件。</li><li><strong>rust-toolchain.toml</strong>：rust 工具链描述文件，指定了使用的 Rust 版本和相关配置。</li><li><strong>setenv.sh</strong>：设置开发环境的脚本，运行该脚本可以配置必要的环境变量。</li><li><strong>user</strong>：用户空间文件夹，存放用户应用程序的源代码。</li></ul><h2 id="执行环境与平台"><a href="#执行环境与平台" class="headerlink" title="执行环境与平台"></a>执行环境与平台</h2><ul><li><p><strong>架构</strong>：RISC-V RV64GC（特权模式：S-mode）</p></li><li><p><strong>QEMU 配置</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">qemu-system-riscv64 \<br>  -machine virt \<br>  -nographic \<br>  -bios none \<br>  -kernel target/riscv64gc-unknown-none-elf/debug/potatos \<br>  -device virtio-blk-device,drive=disk0 \<br>  -drive file=fs.img,format=raw,<span class="hljs-built_in">id</span>=disk0<br></code></pre></td></tr></table></figure><ul><li><code>-machine virt</code>：指定使用 QEMU 的虚拟硬件模型。</li><li><code>-nographic</code>：不使用图形界面，以文本模式运行。如果需要图形化界面，可以去掉该选项。</li><li><code>-bios none</code>：不使用 BIOS。</li><li><code>-kernel target/riscv64gc-unknown-none-elf/debug/potatos</code>：指定要加载的内核二进制文件。</li><li><code>-device virtio-blk-device,drive=disk0</code>：添加一个 Virtio 块设备。</li><li><code>-drive file=fs.img,format=raw,id=disk0</code>：指定使用的磁盘镜像文件。</li></ul></li></ul><h3 id="RustSbi"><a href="#RustSbi" class="headerlink" title="RustSbi"></a>RustSbi</h3><p><code>SBI</code>是RISC-V定义的一组接口规范，用于操作系统与硬件间的沟通。<code>RustSbi</code>是连接该操作系统与底层硬件的桥梁，主要有以下功能：</p><ul><li><strong>硬件抽象</strong>：将硬件访问抽象成接口，使得操作系统内核可以通过统一的接口访问不同的硬件设备，提高了代码的可移植性。</li><li><strong>系统启动</strong>：上电时 Sbi 负责初始化硬件，然后从存储中加载到操作系统。它会完成一些必要的硬件初始化工作，如设置内存映射、初始化中断控制器等，为操作系统的启动做好准备。</li><li><strong>异常和中断处理</strong>：当发生异常或中断时，操作系统把硬件控制权交给 Sbi，Sbi 在底层完成处理后交还控制权。Sbi 可以处理一些底层的异常和中断，如定时器中断、外部设备中断等，减轻了操作系统内核的负担。</li></ul><h2 id="Boot"><a href="#Boot" class="headerlink" title="Boot"></a>Boot</h2><p>通过Qemu启动</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile">QEMU_ARGS := -machine virt \<br> -bios <span class="hljs-variable">$(BOOTLOADER)</span> \<br> -serial stdio \<br> <span class="hljs-variable">$(GUI_OPTION)</span> \<br> -device loader,file=<span class="hljs-variable">$(KERNEL_BIN)</span>,addr=<span class="hljs-variable">$(KERNEL_ENTRY_PA)</span> \<br> -drive file=<span class="hljs-variable">$(FS_IMG)</span>,if=none,format=raw,id=x0 \<br> -device virtio-blk-device,drive=x0 \<br> -device virtio-gpu-device \<br> -device virtio-keyboard-device \<br> -device virtio-mouse-device \<br> -device virtio-net-device,netdev=net0 \<br> -netdev user,id=net0,hostfwd=udp::6200-:2000,hostfwd=tcp::6201-:80<br></code></pre></td></tr></table></figure><p>将编译好的kernel二进制文件加载到对应的启动位置，这里是<code>0x80200000</code></p><h2 id="中断-特权级机制"><a href="#中断-特权级机制" class="headerlink" title="中断&#x2F;特权级机制"></a>中断&#x2F;特权级机制</h2><p>RISC-V为了给操作系统一个稳定的运行环境，不会被应用所干扰，设计了一个特权级机制。这里我们主要是实现这一部分的功能。</p><h3 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h3><ol><li><strong>用户程序执行触发 Trap</strong>：当用户程序执行某些特殊指令或发生异常时，会触发 Trap 机制，将控制权转移到操作系统内核。</li><li><strong>硬件自动保存 <code>sepc</code>、<code>sstatus</code> 等寄存器到内核空间的 <code>TrapContext</code></strong>：<code>sepc</code> 保存了 Trap 发生时的程序计数器，<code>sstatus</code> 保存了当前的状态信息。硬件会自动将这些寄存器的值保存到内核空间的 <code>TrapContext</code> 中，以便后续恢复。</li><li><strong>内核读取 <code>TrapContext</code>，执行 <code>trap_handler</code> 处理逻辑（如系统调用服务）</strong>：内核从 <code>TrapContext</code> 中读取相关信息，根据不同的 Trap 原因执行相应的处理逻辑，如处理系统调用、异常处理等。</li><li><strong>处理完毕后，从 <code>TrapContext</code> 恢复用户寄存器（<code>x</code>、<code>sstatus</code>），通过 <code>sret</code> 指令跳回 <code>sepc</code> 继续执行用户程序</strong>：处理完 Trap 后，内核将用户寄存器的值从 <code>TrapContext</code> 中恢复，并通过 <code>sret</code> 指令将控制权交还给用户程序，继续执行后续的指令。</li></ol><h4 id="用户栈-内核栈"><a href="#用户栈-内核栈" class="headerlink" title="用户栈&#x2F;内核栈"></a>用户栈&#x2F;内核栈</h4><p>区分两个栈是为了应用程序不会通过栈信息读取到内核的控制流，从而避免了一定的安全隐患。</p><p>但在PotatOS里，用户栈被简单地抽象成了<strong>应用栈</strong></p><p>内核栈与进程绑定，抽象成了进程独立且隔离的<strong>进程栈</strong></p><h4 id="上下文切换-恢复"><a href="#上下文切换-恢复" class="headerlink" title="上下文切换&#x2F;恢复"></a>上下文切换&#x2F;恢复</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TrapContext</span> &#123;<br>    <span class="hljs-keyword">pub</span> x: [<span class="hljs-type">usize</span>; <span class="hljs-number">32</span>],<br>    <span class="hljs-keyword">pub</span> sstatus: Sstatus,<br>    <span class="hljs-keyword">pub</span> sepc: <span class="hljs-type">usize</span>,<br>    <span class="hljs-keyword">pub</span> kernel_satp: <span class="hljs-type">usize</span>,<br>    <span class="hljs-keyword">pub</span> kernel_sp: <span class="hljs-type">usize</span>,<br>    <span class="hljs-keyword">pub</span> trap_handler: <span class="hljs-type">usize</span>,<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>x</code>：保存32个通用寄存器的值，暂存用户空间的寄存器状态，以便陷阱处理完毕后恢复执行</li><li><code>sstatus</code>：保存超级用户状态寄存器(Sstatus)的值，记录当前特权级，中断使能，状态标志，用于状态恢复</li><li><code>sepc</code>：保存超级用户异常程序计数器(SEPC)的值，记录trap发生时的地址</li><li><code>kernel_satp</code> ：内核地址空间的 token ，即内核页表的起始物理地址</li><li><code>kernel_sp</code> ：当前应用在内核地址空间中的内核栈栈顶的虚拟地址</li><li><code>trap_handler</code> ：内核中 trap handler 入口点的虚拟地址</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.altmacro<br>.macro SAVE_GP n<br>    sd x\n, \n*8(sp)<br>.endm<br>.macro LOAD_GP n<br>    ld x\n, \n*8(sp)<br>.endm<br>    .section .text.trampoline<br>    .globl __alltraps<br>    .globl __restore<br>    .globl __alltraps_k<br>    .globl __restore_k<br>    .align 2<br>__alltraps:<br>    csrrw sp, sscratch, sp<br>    # now sp-&gt;*TrapContext in user space, sscratch-&gt;user stack<br>    # save other general purpose registers<br>    sd x1, 1*8(sp)<br>    # skip sp(x2), we will save it later<br>    sd x3, 3*8(sp)<br>    # skip tp(x4), application does not use it<br>    # save x5~x31<br>    .set n, 5<br>    .rept 27<br>        SAVE_GP %n<br>        .set n, n+1<br>    .endr<br>    # we can use t0/t1/t2 freely, because they have been saved in TrapContext<br>    csrr t0, sstatus<br>    csrr t1, sepc<br>    sd t0, 32*8(sp)<br>    sd t1, 33*8(sp)<br>    # read user stack from sscratch and save it in TrapContext<br>    csrr t2, sscratch<br>    sd t2, 2*8(sp)<br>    # load kernel_satp into t0<br>    ld t0, 34*8(sp)<br>    # load trap_handler into t1<br>    ld t1, 36*8(sp)<br>    # move to kernel_sp<br>    ld sp, 35*8(sp)<br>    # switch to kernel space<br>    csrw satp, t0<br>    sfence.vma<br>    # jump to trap_handler<br>    jr t1<br><br>__restore:<br>    # a0: *TrapContext in user space(Constant); a1: user space token<br>    # switch to user space<br>    csrw satp, a1<br>    sfence.vma<br>    csrw sscratch, a0<br>    mv sp, a0<br>    # now sp points to TrapContext in user space, start restoring based on it<br>    # restore sstatus/sepc<br>    ld t0, 32*8(sp)<br>    ld t1, 33*8(sp)<br>    csrw sstatus, t0<br>    csrw sepc, t1<br>    # restore general purpose registers except x0/sp/tp<br>    ld x1, 1*8(sp)<br>    ld x3, 3*8(sp)<br>    .set n, 5<br>    .rept 27<br>        LOAD_GP %n<br>        .set n, n+1<br>    .endr<br>    # back to user stack<br>    ld sp, 2*8(sp)<br>    sret<br><br>    .align 2<br></code></pre></td></tr></table></figure><ul><li><code>__alltraps</code>：保存 trap 上下文至内核栈。在发生 Trap 时，该函数会将用户空间的寄存器状态保存到内核栈的 <code>TrapContext</code> 中，并切换到内核空间。</li><li><code>__restore</code>：恢复 trap 上下文。在处理完 Trap 后，该函数会从 <code>TrapContext</code> 中恢复用户寄存器的值，并切换回用户空间，继续执行用户程序。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">trap_return</span>() <span class="hljs-punctuation">-&gt;</span> ! &#123;<br>    <span class="hljs-title function_ invoke__">current_task</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">inner_exclusive_access</span>(<span class="hljs-built_in">file!</span>(), <span class="hljs-built_in">line!</span>()).<span class="hljs-title function_ invoke__">user_time_start</span>();<br><br>    <span class="hljs-title function_ invoke__">disable_supervisor_interrupt</span>();<br>    <span class="hljs-title function_ invoke__">set_user_trap_entry</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">trap_cx_user_va</span> = <span class="hljs-title function_ invoke__">current_trap_cx_user_va</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">user_satp</span> = <span class="hljs-title function_ invoke__">current_user_token</span>();<br>    <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">__alltraps</span>();<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">__restore</span>();<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">restore_va</span> = __restore <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span> - __alltraps <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span> + TRAMPOLINE;<br>    <span class="hljs-comment">//println!(&quot;before return&quot;);</span><br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        asm!(<br>            <span class="hljs-string">&quot;fence.i&quot;</span>,<br>            <span class="hljs-string">&quot;jr &#123;restore_va&#125;&quot;</span>,<br>            restore_va = <span class="hljs-title function_ invoke__">in</span>(reg) restore_va,<br>            <span class="hljs-title function_ invoke__">in</span>(<span class="hljs-string">&quot;a0&quot;</span>) trap_cx_user_va,<br>            <span class="hljs-title function_ invoke__">in</span>(<span class="hljs-string">&quot;a1&quot;</span>) user_satp,<br>            <span class="hljs-title function_ invoke__">options</span>(noreturn)<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在trap恢复时调用上面的函数回到正确的栈空间内。</p><h4 id="trap处理"><a href="#trap处理" class="headerlink" title="trap处理"></a>trap处理</h4><p>当发生 Trap 时，操作系统会根据 Trap 的原因执行相应的处理逻辑。常见的 Trap 原因包括系统调用、异常和中断等。在 <code>trap_handler</code> 函数中，会根据不同的 Trap 原因进行分类处理，如处理系统调用时会根据系统调用号执行相应的服务函数，处理异常时会进行错误处理和恢复，处理中断时会调用相应的中断处理函数。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">trap_handler</span>() <span class="hljs-punctuation">-&gt;</span> ! &#123;<br>    <span class="hljs-title function_ invoke__">set_kernel_trap_entry</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">scause</span> = scause::<span class="hljs-title function_ invoke__">read</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">stval</span> = stval::<span class="hljs-title function_ invoke__">read</span>();<br>    <span class="hljs-comment">// println!(&quot;into &#123;:?&#125;&quot;, scause.cause());</span><br>    <span class="hljs-keyword">match</span> scause.<span class="hljs-title function_ invoke__">cause</span>() &#123;<br>        Trap::<span class="hljs-title function_ invoke__">Exception</span>(Exception::UserEnvCall) =&gt; &#123;<br>            <span class="hljs-title function_ invoke__">current_task</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">inner_exclusive_access</span>(<span class="hljs-built_in">file!</span>(), <span class="hljs-built_in">line!</span>()).<span class="hljs-title function_ invoke__">user_time_end</span>();<br>            <br>            <span class="hljs-comment">// jump to next instruction anyway</span><br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cx</span> = <span class="hljs-title function_ invoke__">current_trap_cx</span>();<br>            cx.sepc += <span class="hljs-number">4</span>;<br><br>            <span class="hljs-title function_ invoke__">enable_supervisor_interrupt</span>();<br><br>            <span class="hljs-comment">// get system call return value</span><br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">syscall</span>(cx.x[<span class="hljs-number">17</span>], [cx.x[<span class="hljs-number">10</span>], cx.x[<span class="hljs-number">11</span>], cx.x[<span class="hljs-number">12</span>]]);<br>            <span class="hljs-comment">// cx is changed during sys_exec, so we have to call it again</span><br>            cx = <span class="hljs-title function_ invoke__">current_trap_cx</span>();<br>            cx.x[<span class="hljs-number">10</span>] = result <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;<br>        &#125;<br>        Trap::<span class="hljs-title function_ invoke__">Exception</span>(Exception::StoreFault)<br>        | Trap::<span class="hljs-title function_ invoke__">Exception</span>(Exception::StorePageFault)<br>        | Trap::<span class="hljs-title function_ invoke__">Exception</span>(Exception::InstructionFault)<br>        | Trap::<span class="hljs-title function_ invoke__">Exception</span>(Exception::InstructionPageFault)<br>        | Trap::<span class="hljs-title function_ invoke__">Exception</span>(Exception::LoadFault)<br>        | Trap::<span class="hljs-title function_ invoke__">Exception</span>(Exception::LoadPageFault) =&gt; &#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            println!(</span><br><span class="hljs-comment">                &quot;[kernel] &#123;:?&#125; in application, bad addr = &#123;:#x&#125;, bad instruction = &#123;:#x&#125;, kernel killed it.&quot;,</span><br><span class="hljs-comment">                scause.cause(),</span><br><span class="hljs-comment">                stval,</span><br><span class="hljs-comment">                current_trap_cx().sepc,</span><br><span class="hljs-comment">            );</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-title function_ invoke__">current_add_signal</span>(SignalFlags::SIGSEGV);<br>        &#125;<br>        Trap::<span class="hljs-title function_ invoke__">Exception</span>(Exception::IllegalInstruction) =&gt; &#123;<br>            <span class="hljs-title function_ invoke__">current_add_signal</span>(SignalFlags::SIGILL);<br>        &#125;<br>        Trap::<span class="hljs-title function_ invoke__">Interrupt</span>(Interrupt::SupervisorTimer) =&gt; &#123;<br>            <span class="hljs-title function_ invoke__">set_next_trigger</span>();<br>            <span class="hljs-title function_ invoke__">check_timer</span>();<br>            <span class="hljs-title function_ invoke__">suspend_current_and_run_next</span>();<br>        &#125;<br>        Trap::<span class="hljs-title function_ invoke__">Interrupt</span>(Interrupt::SupervisorExternal) =&gt; &#123;<br>            crate::board::<span class="hljs-title function_ invoke__">irq_handler</span>();<br>        &#125;<br>        _ =&gt; &#123;<br>            <span class="hljs-built_in">panic!</span>(<br>                <span class="hljs-string">&quot;Unsupported trap &#123;:?&#125;, stval = &#123;:#x&#125;!&quot;</span>,<br>                scause.<span class="hljs-title function_ invoke__">cause</span>(),<br>                stval<br>            );<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// check signals</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>((errno, msg)) = <span class="hljs-title function_ invoke__">check_signals_of_current</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;[kernel] &#123;&#125;&quot;</span>, msg);<br>        <span class="hljs-title function_ invoke__">exit_current_and_run_next</span>(errno);<br>    &#125;<br>    <span class="hljs-title function_ invoke__">trap_return</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这里通过<code>match</code>语句实现中断向量查找-匹配-处理。</p><h3 id="跳板-Trampoline"><a href="#跳板-Trampoline" class="headerlink" title="跳板(Trampoline)"></a>跳板(Trampoline)</h3><p>在传统的OS中，一个应用的用户和内核态通常分配在同一个地址空间的高位和低位，这样可以方便地使用栈寄存器进行跳转。但是，这样做会有内核工作流泄露的风险。所以需要一个跳板来保存工作流调用访问链条。</p><img src="C:\Users\Kid_A\AppData\Roaming\Typora\typora-user-images\image-20250530132531781.png" alt="image-20250530132531781" style="zoom: 50%;" /><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// os/src/mm/memory_set.rs</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">map_trampoline</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>    <span class="hljs-keyword">self</span>.page_table.<span class="hljs-title function_ invoke__">map</span>(<br>        VirtAddr::<span class="hljs-title function_ invoke__">from</span>(TRAMPOLINE).<span class="hljs-title function_ invoke__">into</span>(),<br>        PhysAddr::<span class="hljs-title function_ invoke__">from</span>(strampoline <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>).<span class="hljs-title function_ invoke__">into</span>(),<br>        PTEFlags::R | PTEFlags::X,<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>这里把虚拟地址的高位都固定映射到<code>trampoline</code>。</p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>在<strong>RISC-V</strong>里，系统调用主要由<code>ecall</code>实现。当用户程序需要执行特权操作，如文件读写、进程创建、内存管理等时，无法直接访问硬件资源，必须通过 <code>ecall</code> 指令请求操作系统内核提供服务。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// usr/src/syscall.rs</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">syscall</span>(id: <span class="hljs-type">usize</span>, args: [<span class="hljs-type">usize</span>; <span class="hljs-number">3</span>]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">isize</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">ret</span>: <span class="hljs-type">isize</span>;<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        core::arch::asm!(<br>            <span class="hljs-string">&quot;ecall&quot;</span>,<br>            <span class="hljs-title function_ invoke__">inlateout</span>(<span class="hljs-string">&quot;x10&quot;</span>) args[<span class="hljs-number">0</span>] =&gt; ret,<br>            <span class="hljs-title function_ invoke__">in</span>(<span class="hljs-string">&quot;x11&quot;</span>) args[<span class="hljs-number">1</span>],<br>            <span class="hljs-title function_ invoke__">in</span>(<span class="hljs-string">&quot;x12&quot;</span>) args[<span class="hljs-number">2</span>],<br>            <span class="hljs-title function_ invoke__">in</span>(<span class="hljs-string">&quot;x17&quot;</span>) id<br>        );<br>    &#125;<br>    ret<br>&#125;<br><br><span class="hljs-comment">// os/src/trap/mod.rs</span><br>Trap::<span class="hljs-title function_ invoke__">Exception</span>(Exception::UserEnvCall) =&gt; &#123;<br>    <span class="hljs-title function_ invoke__">current_task</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">inner_exclusive_access</span>(<span class="hljs-built_in">file!</span>(), <span class="hljs-built_in">line!</span>()).<span class="hljs-title function_ invoke__">user_time_end</span>();    <br>    <span class="hljs-comment">// jump to next instruction anyway</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cx</span> = <span class="hljs-title function_ invoke__">current_trap_cx</span>();<br>    cx.sepc += <span class="hljs-number">4</span>;<br>    <span class="hljs-title function_ invoke__">enable_supervisor_interrupt</span>();<br>    <span class="hljs-comment">// get system call return value</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">syscall</span>(cx.x[<span class="hljs-number">17</span>], [cx.x[<span class="hljs-number">10</span>], cx.x[<span class="hljs-number">11</span>], cx.x[<span class="hljs-number">12</span>]]);<br>    <span class="hljs-comment">// cx is changed during sys_exec, so we have to call it again</span><br>    cx = <span class="hljs-title function_ invoke__">current_trap_cx</span>();<br>    cx.x[<span class="hljs-number">10</span>] = result <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>;<br>&#125;<br><br><span class="hljs-comment">// os/src/syscall/mod.rs</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">syscall</span>(syscall_id: <span class="hljs-type">usize</span>, args: [<span class="hljs-type">usize</span>; <span class="hljs-number">3</span>]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">isize</span> &#123;<br>    <span class="hljs-keyword">match</span> syscall_id &#123;<br>        SYSCALL_FSTAT =&gt; <span class="hljs-title function_ invoke__">sys_fstat</span>(args[<span class="hljs-number">0</span>], args[<span class="hljs-number">1</span>]),<br>        SYSCALL_GETCWD =&gt; <span class="hljs-title function_ invoke__">sys_getcwd</span>(args[<span class="hljs-number">0</span>] <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-type">u8</span>, args[<span class="hljs-number">1</span>]),<br>        <span class="hljs-comment">// ...</span><br>        _ =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Unsupported syscall_id: &#123;&#125;&quot;</span>, syscall_id),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>syscall</code>通过<code>ecall</code>发起<code>UserEnvCall</code>，传递函数名(枚举)和参数，找到并执行对应的系统调用函数。</p><blockquote><p>ecall</p><ol><li>系统调用接口</li></ol><p><code>ecall</code> 指令的主要用途是实现<strong>系统调用</strong>（System Call）。当用户程序需要执行特权操作（如文件读写、进程创建、内存管理等）时，无法直接访问硬件资源，必须通过 <code>ecall</code> 指令请求操作系统内核提供服务。</p><ol start="2"><li>特权级切换</li></ol><ul><li><strong>用户模式（U-mode）</strong>：用户程序运行在此模式，权限受限，无法直接访问硬件或执行特权指令。</li><li><strong>监管者模式（S-mode）</strong>：操作系统内核运行在此模式，拥有完整的硬件访问权限。</li><li><strong><code>ecall</code> 的作用</strong>：将处理器从 U-mode 切换到 S-mode，并跳转到内核预先设置的<strong>陷阱处理程序</strong>（Trap Handler）。</li></ul></blockquote><h2 id="地址空间管理"><a href="#地址空间管理" class="headerlink" title="地址空间管理"></a>地址空间管理</h2><p>OS需要提供虚拟地址，需要进行物理地址和虚拟地址的转换，需要动态分配地址空间。</p><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>在PotatOS中，内存主要由<code>page, page table, frame</code>管理。</p><ul><li><strong>page</strong>：虚拟内存的单位，通常为 4KiB。操作系统将虚拟地址空间划分为多个页面，方便进行内存管理和保护。</li><li><strong>frame</strong>：物理内存的单位，也通常为 4KiB。物理内存被划分为多个帧，用于存储页面的数据。</li><li><strong>page_table</strong>：虚拟地址到物理地址的转换表。通过页表，操作系统可以将虚拟地址映射到对应的物理地址，实现虚拟内存和物理内存的分离。</li></ul><h3 id="内存管理者模型"><a href="#内存管理者模型" class="headerlink" title="内存管理者模型"></a>内存管理者模型</h3><p>我们通过固定分配的<strong>HEAP_ALLOCATOR</strong>作为内核的堆存储空间，<strong>FRAME_ALLOCATOR</strong>作为动态分配的栈空间。他们分别从地址空间的开始&#x2F;结尾分配内存。</p><h5 id="HEAP-ALLOCATOR"><a href="#HEAP-ALLOCATOR" class="headerlink" title="HEAP-ALLOCATOR"></a>HEAP-ALLOCATOR</h5><p>简单地使用一段数组来分配数据</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[global_allocator]</span><br><span class="hljs-keyword">static</span> HEAP_ALLOCATOR: LockedHeap = LockedHeap::<span class="hljs-title function_ invoke__">empty</span>();<br><br><span class="hljs-meta">#[alloc_error_handler]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">handle_alloc_error</span>(layout: core::alloc::Layout) <span class="hljs-punctuation">-&gt;</span> ! &#123;<br>    <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Heap allocation error, layout = &#123;:?&#125;&quot;</span>, layout);<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> HEAP_SPACE: [<span class="hljs-type">u8</span>; KERNEL_HEAP_SIZE] = [<span class="hljs-number">0</span>; KERNEL_HEAP_SIZE];<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">init_heap</span>() &#123;<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        HEAP_ALLOCATOR<br>            .<span class="hljs-title function_ invoke__">lock</span>()<br>            .<span class="hljs-title function_ invoke__">init</span>(HEAP_SPACE.<span class="hljs-title function_ invoke__">as_ptr</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>, KERNEL_HEAP_SIZE);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><code>HEAP_ALLOCATOR</code>：全局堆分配器，用于管理内核的堆内存。</li><li><code>handle_alloc_error</code>：堆分配错误处理函数，当堆分配失败时会触发该函数。</li><li><code>HEAP_SPACE</code>：堆内存空间，是一个固定大小的数组。</li><li><code>init_heap</code>：初始化堆分配器，将堆内存空间的起始地址和大小传递给堆分配器。</li></ul><h5 id="FRAME-ALLOCATOR"><a href="#FRAME-ALLOCATOR" class="headerlink" title="FRAME_ALLOCATOR"></a>FRAME_ALLOCATOR</h5><p>使用简单的<strong>双指针标记</strong>，顺序遍历来分配物理页帧。设置了全局静态<code>FRAME_ALLOCATOR</code>来包装并分配。</p><p><strong>ekernel</strong>表示数据段的结尾。尽管形式上是这样的，我还是倾向于栈由高位向低位分配。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">StackFrameAllocator</span> &#123;<br>    current: <span class="hljs-type">usize</span>,<br>    end: <span class="hljs-type">usize</span>,<br>    recycled: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">usize</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">StackFrameAllocator</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">init</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, l: PhysPageNum, r: PhysPageNum) &#123;<br>        <span class="hljs-keyword">self</span>.current = l.<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">self</span>.end = r.<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">FrameAllocator</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">StackFrameAllocator</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">Self</span> &#123;<br>            current: <span class="hljs-number">0</span>,<br>            end: <span class="hljs-number">0</span>,<br>            recycled: <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>(),<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">alloc</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;PhysPageNum&gt; &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(ppn) = <span class="hljs-keyword">self</span>.recycled.<span class="hljs-title function_ invoke__">pop</span>() &#123;<br>            <span class="hljs-title function_ invoke__">Some</span>(ppn.<span class="hljs-title function_ invoke__">into</span>())<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.current == <span class="hljs-keyword">self</span>.end &#123;<br>            <span class="hljs-literal">None</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">self</span>.current += <span class="hljs-number">1</span>;<br>            <span class="hljs-title function_ invoke__">Some</span>((<span class="hljs-keyword">self</span>.current - <span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">into</span>())<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">alloc_more</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, pages: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">Vec</span>&lt;PhysPageNum&gt;&gt; &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.current + pages &gt;= <span class="hljs-keyword">self</span>.end &#123;<br>            <span class="hljs-literal">None</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">self</span>.current += pages;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">usize</span>&gt; = (<span class="hljs-number">1</span>..pages + <span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">collect</span>();<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = arr.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">map</span>(|x| (<span class="hljs-keyword">self</span>.current - x).<span class="hljs-title function_ invoke__">into</span>()).<span class="hljs-title function_ invoke__">collect</span>();<br>            <span class="hljs-title function_ invoke__">Some</span>(v)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">dealloc</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, ppn: PhysPageNum) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">ppn</span> = ppn.<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// validity check</span><br>        <span class="hljs-keyword">if</span> ppn &gt;= <span class="hljs-keyword">self</span>.current || <span class="hljs-keyword">self</span>.recycled.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">any</span>(|&amp;v| v == ppn) &#123;<br>            <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Frame ppn=&#123;:#x&#125; has not been allocated!&quot;</span>, ppn);<br>        &#125;<br>        <span class="hljs-comment">// recycle</span><br>        <span class="hljs-keyword">self</span>.recycled.<span class="hljs-title function_ invoke__">push</span>(ppn);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">FrameAllocatorImpl</span> = StackFrameAllocator;<br><br>lazy_static! &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">ref</span> FRAME_ALLOCATOR: UPIntrFreeCell&lt;FrameAllocatorImpl&gt; =<br>        <span class="hljs-keyword">unsafe</span> &#123; UPIntrFreeCell::<span class="hljs-title function_ invoke__">new</span>(FrameAllocatorImpl::<span class="hljs-title function_ invoke__">new</span>()) &#125;;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">init_frame_allocator</span>() &#123;<br>    <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">ekernel</span>();<br>    &#125;<br>    FRAME_ALLOCATOR.<span class="hljs-title function_ invoke__">exclusive_access</span>(<span class="hljs-built_in">file!</span>(), <span class="hljs-built_in">line!</span>()).<span class="hljs-title function_ invoke__">init</span>(<br>        PhysAddr::<span class="hljs-title function_ invoke__">from</span>(ekernel <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>).<span class="hljs-title function_ invoke__">ceil</span>(),<br>        PhysAddr::<span class="hljs-title function_ invoke__">from</span>(MEMORY_END).<span class="hljs-title function_ invoke__">floor</span>(),<br>    );<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">frame_alloc</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;FrameTracker&gt; &#123;<br>    FRAME_ALLOCATOR<br>        .<span class="hljs-title function_ invoke__">exclusive_access</span>(<span class="hljs-built_in">file!</span>(), <span class="hljs-built_in">line!</span>())<br>        .<span class="hljs-title function_ invoke__">alloc</span>()<br>        .<span class="hljs-title function_ invoke__">map</span>(FrameTracker::new)<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">frame_alloc_more</span>(num: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">Vec</span>&lt;FrameTracker&gt;&gt; &#123;<br>    FRAME_ALLOCATOR<br>        .<span class="hljs-title function_ invoke__">exclusive_access</span>(<span class="hljs-built_in">file!</span>(), <span class="hljs-built_in">line!</span>())<br>        .<span class="hljs-title function_ invoke__">alloc_more</span>(num)<br>        .<span class="hljs-title function_ invoke__">map</span>(|x| x.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">map</span>(|&amp;t| FrameTracker::<span class="hljs-title function_ invoke__">new</span>(t)).<span class="hljs-title function_ invoke__">collect</span>())<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">frame_dealloc</span>(ppn: PhysPageNum) &#123;<br>    FRAME_ALLOCATOR.<span class="hljs-title function_ invoke__">exclusive_access</span>(<span class="hljs-built_in">file!</span>(), <span class="hljs-built_in">line!</span>()).<span class="hljs-title function_ invoke__">dealloc</span>(ppn);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>StackFrameAllocator</code>：栈帧分配器，使用双指针标记和回收机制来管理物理页帧。</li><li><code>init</code>：初始化栈帧分配器，设置起始和结束地址。</li><li><code>alloc</code>：分配一个物理页帧。如果有回收的页帧，则优先使用；否则，从当前位置分配一个新的页帧。</li><li><code>alloc_more</code>：分配多个物理页帧。</li><li><code>dealloc</code>：释放一个物理页帧，并将其加入回收列表。</li><li><code>FRAME_ALLOCATOR</code>：全局帧分配器，使用 <code>lazy_static</code> 进行静态初始化。</li><li><code>init_frame_allocator</code>：初始化帧分配器，设置分配范围。</li><li><code>frame_alloc</code>：分配一个帧，并返回一个 <code>FrameTracker</code> 对象。</li><li><code>frame_alloc_more</code>：分配多个帧，并返回一个 <code>FrameTracker</code> 对象的向量。</li><li><code>frame_dealloc</code>：释放一个帧。</li></ul><h3 id="多级页表管理地址空间-SV39"><a href="#多级页表管理地址空间-SV39" class="headerlink" title="多级页表管理地址空间(SV39)"></a>多级页表管理地址空间(SV39)</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>我们希望实现物理地址和虚拟地址的转换和分页管理地址空间，因此需要一个标准。基于SV39实现的地址符合以下要求。</p><p><strong>地址格式</strong></p><p><img src="https://rcore-os.cn/rCore-Tutorial-Book-v3/_images/sv39-va-pa.png" alt="..&#x2F;_images&#x2F;sv39-va-pa.png"></p><p><strong>页表格式</strong></p><p><img src="https://rcore-os.cn/rCore-Tutorial-Book-v3/_images/sv39-pte.png" alt="..&#x2F;_images&#x2F;sv39-pte.png"></p><p>可以发现我们划分了 4KiB 大小的 page 用于对齐。SV39 是 RISC-V 架构中的一种页表机制，它将 39 位的虚拟地址划分为三个 9 位的虚拟页号和 12 位的页内偏移，将 56 位的物理地址划分为物理页号和页内偏移。通过多级页表的方式，实现虚拟地址到物理地址的转换。</p><h4 id="Address"><a href="#Address" class="headerlink" title="Address"></a>Address</h4><p>按照标准实现了地址的包装，包括地址之间的转换，page内bits的读取等等</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// os/src/mm/address.rs</span><br><span class="hljs-keyword">const</span> PA_WIDTH_SV39: <span class="hljs-type">usize</span> = <span class="hljs-number">56</span>;<br><span class="hljs-keyword">const</span> VA_WIDTH_SV39: <span class="hljs-type">usize</span> = <span class="hljs-number">39</span>;<br><span class="hljs-comment">/// PAGE_SIZE_BITS = 0x12(4KiB)</span><br><span class="hljs-keyword">const</span> PPN_WIDTH_SV39: <span class="hljs-type">usize</span> = PA_WIDTH_SV39 - PAGE_SIZE_BITS;<br><span class="hljs-keyword">const</span> VPN_WIDTH_SV39: <span class="hljs-type">usize</span> = VA_WIDTH_SV39 - PAGE_SIZE_BITS;<br><br><span class="hljs-comment">/// Definitions</span><br><span class="hljs-meta">#[repr(C)]</span><br><span class="hljs-meta">#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PhysAddr</span>(<span class="hljs-keyword">pub</span> <span class="hljs-type">usize</span>);<br><br><span class="hljs-meta">#[repr(C)]</span><br><span class="hljs-meta">#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">VirtAddr</span>(<span class="hljs-keyword">pub</span> <span class="hljs-type">usize</span>);<br><br><span class="hljs-meta">#[repr(C)]</span><br><span class="hljs-meta">#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PhysPageNum</span>(<span class="hljs-keyword">pub</span> <span class="hljs-type">usize</span>);<br><br><span class="hljs-meta">#[repr(C)]</span><br><span class="hljs-meta">#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">VirtPageNum</span>(<span class="hljs-keyword">pub</span> <span class="hljs-type">usize</span>);<br><br><span class="hljs-comment">/// Debugging</span><br><span class="hljs-comment">/// ...</span><br><br><span class="hljs-comment">/// T: &#123;PhysAddr, VirtAddr, PhysPageNum, VirtPageNum&#125;</span><br><span class="hljs-comment">/// T -&gt; usize: T.0</span><br><span class="hljs-comment">/// usize -&gt; T: usize.into()</span><br><br><span class="hljs-comment">/// transformations of addresses</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;<span class="hljs-type">usize</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">PhysAddr</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(v: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-title function_ invoke__">Self</span>(v &amp; ((<span class="hljs-number">1</span> &lt;&lt; PA_WIDTH_SV39) - <span class="hljs-number">1</span>))<br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;<span class="hljs-type">usize</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">PhysPageNum</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(v: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-title function_ invoke__">Self</span>(v &amp; ((<span class="hljs-number">1</span> &lt;&lt; PPN_WIDTH_SV39) - <span class="hljs-number">1</span>))<br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;<span class="hljs-type">usize</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">VirtAddr</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(v: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-title function_ invoke__">Self</span>(v &amp; ((<span class="hljs-number">1</span> &lt;&lt; VA_WIDTH_SV39) - <span class="hljs-number">1</span>))<br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;<span class="hljs-type">usize</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">VirtPageNum</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(v: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-title function_ invoke__">Self</span>(v &amp; ((<span class="hljs-number">1</span> &lt;&lt; VPN_WIDTH_SV39) - <span class="hljs-number">1</span>))<br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;PhysAddr&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">usize</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(v: PhysAddr) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        v.<span class="hljs-number">0</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;PhysPageNum&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">usize</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(v: PhysPageNum) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        v.<span class="hljs-number">0</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;VirtAddr&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">usize</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(v: VirtAddr) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">if</span> v.<span class="hljs-number">0</span> &gt;= (<span class="hljs-number">1</span> &lt;&lt; (VA_WIDTH_SV39 - <span class="hljs-number">1</span>)) &#123;<br>            v.<span class="hljs-number">0</span> | (!((<span class="hljs-number">1</span> &lt;&lt; VA_WIDTH_SV39) - <span class="hljs-number">1</span>))<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            v.<span class="hljs-number">0</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;VirtPageNum&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">usize</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(v: VirtPageNum) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        v.<span class="hljs-number">0</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/// get page num by address</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">VirtAddr</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">floor</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> VirtPageNum &#123;<br>        <span class="hljs-title function_ invoke__">VirtPageNum</span>(<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span> / PAGE_SIZE)<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">ceil</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> VirtPageNum &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span> == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-title function_ invoke__">VirtPageNum</span>(<span class="hljs-number">0</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-title function_ invoke__">VirtPageNum</span>((<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span> - <span class="hljs-number">1</span> + PAGE_SIZE) / PAGE_SIZE)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">page_offset</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>        <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span> &amp; (PAGE_SIZE - <span class="hljs-number">1</span>)<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">aligned</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">page_offset</span>() == <span class="hljs-number">0</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;VirtAddr&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">VirtPageNum</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(v: VirtAddr) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-built_in">assert_eq!</span>(v.<span class="hljs-title function_ invoke__">page_offset</span>(), <span class="hljs-number">0</span>);<br>        v.<span class="hljs-title function_ invoke__">floor</span>()<br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;VirtPageNum&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">VirtAddr</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(v: VirtPageNum) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-title function_ invoke__">Self</span>(v.<span class="hljs-number">0</span> &lt;&lt; PAGE_SIZE_BITS)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">PhysAddr</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">floor</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> PhysPageNum &#123;<br>        <span class="hljs-title function_ invoke__">PhysPageNum</span>(<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span> / PAGE_SIZE)<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">ceil</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> PhysPageNum &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span> == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-title function_ invoke__">PhysPageNum</span>(<span class="hljs-number">0</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-title function_ invoke__">PhysPageNum</span>((<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span> - <span class="hljs-number">1</span> + PAGE_SIZE) / PAGE_SIZE)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">page_offset</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>        <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span> &amp; (PAGE_SIZE - <span class="hljs-number">1</span>)<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">aligned</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">page_offset</span>() == <span class="hljs-number">0</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;PhysAddr&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">PhysPageNum</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(v: PhysAddr) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-built_in">assert_eq!</span>(v.<span class="hljs-title function_ invoke__">page_offset</span>(), <span class="hljs-number">0</span>);<br>        v.<span class="hljs-title function_ invoke__">floor</span>()<br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;PhysPageNum&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">PhysAddr</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(v: PhysPageNum) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-title function_ invoke__">Self</span>(v.<span class="hljs-number">0</span> &lt;&lt; PAGE_SIZE_BITS)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">VirtPageNum</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">indexes</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> [<span class="hljs-type">usize</span>; <span class="hljs-number">3</span>] &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">vpn</span> = <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">idx</span> = [<span class="hljs-number">0usize</span>; <span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">0</span>..<span class="hljs-number">3</span>).<span class="hljs-title function_ invoke__">rev</span>() &#123;<br>            idx[i] = vpn &amp; <span class="hljs-number">511</span>;<br>            vpn &gt;&gt;= <span class="hljs-number">9</span>;<br>        &#125;<br>        idx<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">PhysAddr</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_ref</span>&lt;T&gt;(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;static</span> T &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123; (<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span> <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> T).<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">unwrap</span>() &#125;<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_mut</span>&lt;T&gt;(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-keyword">mut</span> T &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123; (<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span> <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> T).<span class="hljs-title function_ invoke__">as_mut</span>().<span class="hljs-title function_ invoke__">unwrap</span>() &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">PhysPageNum</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_pte_array</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-keyword">mut</span> [PageTableEntry] &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">pa</span>: PhysAddr = (*<span class="hljs-keyword">self</span>).<span class="hljs-title function_ invoke__">into</span>();<br>        <span class="hljs-keyword">unsafe</span> &#123; core::slice::<span class="hljs-title function_ invoke__">from_raw_parts_mut</span>(pa.<span class="hljs-number">0</span> <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> PageTableEntry, <span class="hljs-number">512</span>) &#125;<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_bytes_array</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-keyword">mut</span> [<span class="hljs-type">u8</span>] &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">pa</span>: PhysAddr = (*<span class="hljs-keyword">self</span>).<span class="hljs-title function_ invoke__">into</span>();<br>        <span class="hljs-keyword">unsafe</span> &#123; core::slice::<span class="hljs-title function_ invoke__">from_raw_parts_mut</span>(pa.<span class="hljs-number">0</span> <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-type">u8</span>, <span class="hljs-number">4096</span>) &#125;<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_mut</span>&lt;T&gt;(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-keyword">mut</span> T &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">pa</span>: PhysAddr = (*<span class="hljs-keyword">self</span>).<span class="hljs-title function_ invoke__">into</span>();<br>        pa.<span class="hljs-title function_ invoke__">get_mut</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>PhysAddr</code>：物理地址结构体，包装了一个 <code>usize</code> 类型的物理地址。</li><li><code>VirtAddr</code>：虚拟地址结构体，包装了一个 <code>usize</code> 类型的虚拟地址。</li><li><code>PhysPageNum</code>：物理页号结构体，包装了一个 <code>usize</code> 类型的物理页号。</li><li><code>VirtPageNum</code>：虚拟页号结构体，包装了一个 <code>usize</code> 类型的虚拟页号。</li><li><code>From</code> 实现：提供了从 <code>usize</code> 类型到各种地址和页号类型的转换。</li><li><code>From</code>、<code>From</code>、<code>From</code>、<code>From</code> 实现：提供了从各种地址和页号类型到 <code>usize</code> 类型的转换。</li><li><code>VirtAddr</code> 和 <code>PhysAddr</code> 的方法：提供了获取页号、页内偏移、判断对齐等功能。</li><li><code>VirtPageNum</code> 的 <code>indexes</code> 方法：将虚拟页号拆分为三个 9 位的索引。</li><li><code>PhysAddr</code> 和 <code>PhysPageNum</code> 的方法：提供了获取引用、修改引用、获取页表项数组等功能。</li></ul><h4 id="PageTable"><a href="#PageTable" class="headerlink" title="PageTable"></a>PageTable</h4><h5 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h5><p><strong>PageTable</strong>主要负责转换虚拟地址和物理地址。SV39有三级页表机制，需要简单的循环和标记位验证解决问题。以下为<strong>xv6</strong>页表变换示意图，同理。</p><p><img src="https://rcore-os.cn/rCore-Tutorial-Book-v3/_images/sv39-full.png" alt="..&#x2F;_images&#x2F;sv39-full.png"></p><p>在 SV39 模式中我们采用三级页表，即将 27 位的虚拟页号分为三个等长的部分，第 26-18 位为一级页索引 <strong>VPN0</strong> ，第 17-9 位为二级页索引 <strong>VPN1</strong> ，第 8-0 位为三级页索引 <strong>VPN2</strong> 。</p><p>我们也将页表分为一级页表（多级页表的根节点），二级页表，三级页表（多级页表的叶节点）。每个页表都用 9 位索引，因此有 29&#x3D;512 个页表项，而每个页表项都是 8 字节，因此每个页表大小都为 512×8&#x3D;4KiB 。正好是一个物理页的大小。我们可以把一个页表放到一个物理页中，并用一个物理页号来描述它。事实上，一级页表的每个页表项中的物理页号可描述一个二级页表；二级页表的每个页表项中的物理页号可描述一个三级页表；三级页表中的页表项内容则和我们刚才提到的页表项一样，其内容包含物理页号，即描述一个要映射到的物理页。</p><p>具体来说，假设我们有虚拟地址 (VPN0,VPN1,VPN2,offset) ：</p><ul><li>我们首先会记录装载「当前所用的一级页表的物理页」的页号到 satp 寄存器中；</li><li>把 VPN0 作为偏移在一级页表的物理页中找到二级页表的物理页号；</li><li>把 VPN1 作为偏移在二级页表的物理页中找到三级页表的物理页号；</li><li>把 VPN2 作为偏移在三级页表的物理页中找到要访问位置的物理页号；</li><li>物理页号对应的物理页基址（即物理页号左移12位）加上 offset 就是虚拟地址对应的物理地址。</li></ul><p>这样处理器通过这种多次转换，终于从虚拟页号找到了一级页表项，从而得出了物理页号和虚拟地址所对应的物理地址。刚才我们提到若页表项满足 R,W,X 都为 0，表明这个页表项指向下一级页表。在这里一级和二级页表项的 R,W,X 为 0 应该成立，因为它们指向了下一级页表。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// os/src/mm/page_table.rs</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">find_pte_create</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, vpn: VirtPageNum) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-keyword">mut</span> PageTableEntry&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">idxs</span> = vpn.<span class="hljs-title function_ invoke__">indexes</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">ppn</span> = <span class="hljs-keyword">self</span>.root_ppn;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">result</span>: <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-keyword">mut</span> PageTableEntry&gt; = <span class="hljs-literal">None</span>;<br>    <span class="hljs-keyword">for</span> (i, idx) <span class="hljs-keyword">in</span> idxs.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">pte</span> = &amp;<span class="hljs-keyword">mut</span> ppn.<span class="hljs-title function_ invoke__">get_pte_array</span>()[*idx];<br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">2</span> &#123;<br>            result = <span class="hljs-title function_ invoke__">Some</span>(pte);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> !pte.<span class="hljs-title function_ invoke__">is_valid</span>() &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">frame</span> = <span class="hljs-title function_ invoke__">frame_alloc</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>            *pte = PageTableEntry::<span class="hljs-title function_ invoke__">new</span>(frame.ppn, PTEFlags::V);<br>            <span class="hljs-keyword">self</span>.frames.<span class="hljs-title function_ invoke__">push</span>(frame);<br>        &#125;<br>        ppn = pte.<span class="hljs-title function_ invoke__">ppn</span>();<br>    &#125;<br>    result<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">find_pte</span>(&amp;<span class="hljs-keyword">self</span>, vpn: VirtPageNum) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-keyword">mut</span> PageTableEntry&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">idxs</span> = vpn.<span class="hljs-title function_ invoke__">indexes</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">ppn</span> = <span class="hljs-keyword">self</span>.root_ppn;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">result</span>: <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-keyword">mut</span> PageTableEntry&gt; = <span class="hljs-literal">None</span>;<br>    <span class="hljs-keyword">for</span> (i, idx) <span class="hljs-keyword">in</span> idxs.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">pte</span> = &amp;<span class="hljs-keyword">mut</span> ppn.<span class="hljs-title function_ invoke__">get_pte_array</span>()[*idx];<br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">2</span> &#123;<br>            result = <span class="hljs-title function_ invoke__">Some</span>(pte);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> !pte.<span class="hljs-title function_ invoke__">is_valid</span>() &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>;<br>        &#125;<br>        ppn = pte.<span class="hljs-title function_ invoke__">ppn</span>();<br>    &#125;<br>    result<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>find_pte_create</code>：查找并创建页表项。如果页表项不存在，则分配一个新的物理页帧，并创建页表项。</li><li><code>find_pte</code>：查找页表项。如果页表项不存在，则返回 <code>None</code>。</li></ul><h5 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h5><p>每个进程有自己的虚拟地址，映射到不同的物理地址中。需要用页表进行映射&#x2F;取消映射和物理地址&#x2F;虚拟地址的转换。</p><p>这里我们采用最简单的恒等映射，即<code>ppn=vpn</code>的方式映射。</p><p>同时，为了区分每个进程的页表，使用<code>Token</code>分辨页表。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// os/src/mm/page_table.rs</span><br><span class="hljs-meta">#[allow(unused)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">map</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, vpn: VirtPageNum, ppn: PhysPageNum, flags: PTEFlags) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">pte</span> = <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">find_pte_create</span>(vpn).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-built_in">assert!</span>(!pte.<span class="hljs-title function_ invoke__">is_valid</span>(), <span class="hljs-string">&quot;vpn &#123;:?&#125; is mapped before mapping&quot;</span>, vpn);<br>    *pte = PageTableEntry::<span class="hljs-title function_ invoke__">new</span>(ppn, flags | PTEFlags::V);<br>&#125;<br><span class="hljs-meta">#[allow(unused)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">unmap</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, vpn: VirtPageNum) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">pte</span> = <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">find_pte</span>(vpn).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-built_in">assert!</span>(pte.<span class="hljs-title function_ invoke__">is_valid</span>(), <span class="hljs-string">&quot;vpn &#123;:?&#125; is invalid before unmapping&quot;</span>, vpn);<br>    *pte = PageTableEntry::<span class="hljs-title function_ invoke__">empty</span>();<br>&#125;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">translate</span>(&amp;<span class="hljs-keyword">self</span>, vpn: VirtPageNum) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;PageTableEntry&gt; &#123;<br>    <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">find_pte</span>(vpn).<span class="hljs-title function_ invoke__">map</span>(|pte| *pte)<br>&#125;<br><span class="hljs-comment">/// ppn + offset</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">translate_va</span>(&amp;<span class="hljs-keyword">self</span>, va: VirtAddr) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;PhysAddr&gt; &#123;<br>    <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">find_pte</span>(va.<span class="hljs-title function_ invoke__">clone</span>().<span class="hljs-title function_ invoke__">floor</span>()).<span class="hljs-title function_ invoke__">map</span>(|pte| &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">aligned_pa</span>: PhysAddr = pte.<span class="hljs-title function_ invoke__">ppn</span>().<span class="hljs-title function_ invoke__">into</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">offset</span> = va.<span class="hljs-title function_ invoke__">page_offset</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">aligned_pa_usize</span>: <span class="hljs-type">usize</span> = aligned_pa.<span class="hljs-title function_ invoke__">into</span>();<br>        (aligned_pa_usize + offset).<span class="hljs-title function_ invoke__">into</span>()<br>    &#125;)<br>&#125;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">token</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    <span class="hljs-number">8usize</span> &lt;&lt; <span class="hljs-number">60</span> | <span class="hljs-keyword">self</span>.root_ppn.<span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>map</code>：将虚拟页号映射到物理页号，并设置相应的标志位。</li><li><code>unmap</code>：取消虚拟页号的映射。</li><li><code>translate</code>：将虚拟页号转换为页表项。</li><li><code>translate_va</code>：将虚拟地址转换为物理地址。</li><li><code>token</code>：生成页表的 token，用于区分不同的页表。</li></ul><h3 id="地址空间管理-1"><a href="#地址空间管理-1" class="headerlink" title="地址空间管理"></a>地址空间管理</h3><h4 id="逻辑段"><a href="#逻辑段" class="headerlink" title="逻辑段"></a>逻辑段</h4><p>前面我们实现了页帧管理和映射机制，但是这太零散了。我们还需要一层抽象来组织页帧。所以逻辑段就是这样的抽象。它组织了一段<strong>连续且可用</strong>的虚拟地址。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// os/src/mm/memory_set.rs</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">MapArea</span> &#123;<br>    vpn_range: VPNRange,<br>    data_frames: BTreeMap&lt;VirtPageNum, FrameTracker&gt;,<br>    map_type: MapType,<br>    map_perm: MapPermission,<br>&#125;<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">map_one</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, page_table: &amp;<span class="hljs-keyword">mut</span> PageTable, vpn: VirtPageNum) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">ppn</span>: PhysPageNum;<br>    <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.map_type &#123;<br>        MapType::Identical =&gt; &#123;<br>            ppn = <span class="hljs-title function_ invoke__">PhysPageNum</span>(vpn.<span class="hljs-number">0</span>);<br>        &#125;<br>        MapType::Framed =&gt; &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">frame</span> = <span class="hljs-title function_ invoke__">frame_alloc</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>            ppn = frame.ppn;<br>            <span class="hljs-keyword">self</span>.data_frames.<span class="hljs-title function_ invoke__">insert</span>(vpn, frame);<br>        &#125;<br>        MapType::<span class="hljs-title function_ invoke__">Linear</span>(pn_offset) =&gt; &#123;<br>            <span class="hljs-comment">// check for sv39</span><br>            <span class="hljs-built_in">assert!</span>(vpn.<span class="hljs-number">0</span> &lt; (<span class="hljs-number">1usize</span> &lt;&lt; <span class="hljs-number">27</span>));<br>            ppn = <span class="hljs-title function_ invoke__">PhysPageNum</span>((vpn.<span class="hljs-number">0</span> <span class="hljs-keyword">as</span> <span class="hljs-type">isize</span> + pn_offset) <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">pte_flags</span> = PTEFlags::<span class="hljs-title function_ invoke__">from_bits</span>(<span class="hljs-keyword">self</span>.map_perm.bits).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    page_table.<span class="hljs-title function_ invoke__">map</span>(vpn, ppn, pte_flags);<br>&#125;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">unmap_one</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, page_table: &amp;<span class="hljs-keyword">mut</span> PageTable, vpn: VirtPageNum) &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.map_type == MapType::Framed &#123;<br>        <span class="hljs-keyword">self</span>.data_frames.<span class="hljs-title function_ invoke__">remove</span>(&amp;vpn);<br>    &#125;<br>    page_table.<span class="hljs-title function_ invoke__">unmap</span>(vpn);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>MapArea</code>：逻辑段结构体，包含虚拟页号范围、数据帧映射、映射类型和映射权限。</li><li><code>vpn_range</code>：一段左右闭合的虚拟地址范围。</li><li><code>data_frames</code>：物理页帧和虚拟地址的映射关系，使用 <code>BTreeMap</code> 存储。</li><li><code>map_type</code>：存在几种映射方式，包括直接映射、线性映射和新建页表随机映射。<ul><li><strong>直接映射</strong>：<code>ppn = vpn</code>，即虚拟页号和物理页号相同。</li><li><strong>线性映射</strong>：通过一个偏移量来计算物理页号。</li><li><strong>新建页表随机映射</strong>：分配一个新的物理页帧，并进行映射。</li></ul></li><li><code>map_perm</code>：是否允许映射，指定了映射的权限，如读、写、执行等。</li><li><code>map_one</code>：按顺序取得 frame 进行映射。根据映射类型选择合适的物理页号，并调用页表的 <code>map</code> 方法进行映射。</li><li><code>unmap_one</code>：删除已映射的 vpn。如果是 <code>Framed</code> 映射类型，还需要从 <code>data_frames</code> 中移除相应的映射关系，并调用页表的 <code>unmap</code> 方法取消映射。</li></ul><h4 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h4><p>相当于为进程组织了一系列逻辑段，给每个进程分配了一个<code>PageTable</code>和<code>MapArea</code>来绑定进程的地址空间。这样每个进程就有了独立的地址空间。非常好的想法。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">MemorySet</span> &#123;<br>    page_table: PageTable,<br>    areas: <span class="hljs-type">Vec</span>&lt;MapArea&gt;,<br>&#125;<br></code></pre></td></tr></table></figure><p>基本就是提供了逻辑段的调用接口。</p><h5 id="内核地址空间"><a href="#内核地址空间" class="headerlink" title="内核地址空间"></a>内核地址空间</h5><p>内核地址空间是操作系统内核所使用的地址空间，通常包含内核代码、数据、栈等。内核地址空间是所有进程共享的，它提供了对系统资源的直接访问，如设备驱动、中断处理等。在 PotatOS 中，内核地址空间的映射和管理是通过 <code>PageTable</code> 和 <code>MapArea</code> 来实现的。内核地址空间的映射通常是静态的，在系统启动时就已经完成。</p><table><thead><tr><th>高位内核栈布局</th><th>低位内核逻辑段布局</th></tr></thead><tbody><tr><td><img src="https://rcore-os.cn/rCore-Tutorial-Book-v3/_images/kernel-as-high.png" alt="内核栈布局"></td><td><img src="https://rcore-os.cn/rCore-Tutorial-Book-v3/_images/kernel-as-low.png" alt="内核逻辑段布局"></td></tr></tbody></table><p>内核地址的分布，高位是应用的内核栈，低位是内核地址空间的逻辑段，按照顺序插入。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new_kernel</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">memory_set</span> = <span class="hljs-keyword">Self</span>::<span class="hljs-title function_ invoke__">new_bare</span>();<br>    <span class="hljs-comment">// map trampoline</span><br>    memory_set.<span class="hljs-title function_ invoke__">map_trampoline</span>();<br>    <span class="hljs-comment">// map kernel sections</span><br>    <span class="hljs-comment">// println!(&quot;mapping .text section&quot;);</span><br>    memory_set.<span class="hljs-title function_ invoke__">push</span>(<br>        MapArea::<span class="hljs-title function_ invoke__">new</span>(<br>            (stext <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>).<span class="hljs-title function_ invoke__">into</span>(),<br>            (etext <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>).<span class="hljs-title function_ invoke__">into</span>(),<br>            MapType::Identical,<br>            MapPermission::R | MapPermission::X,<br>        ),<br>        <span class="hljs-literal">None</span>,<br>    );<br>    <span class="hljs-comment">// println!(&quot;mapping .rodata section&quot;);</span><br>    memory_set.<span class="hljs-title function_ invoke__">push</span>(<br>        MapArea::<span class="hljs-title function_ invoke__">new</span>(<br>            (srodata <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>).<span class="hljs-title function_ invoke__">into</span>(),<br>            (erodata <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>).<span class="hljs-title function_ invoke__">into</span>(),<br>            MapType::Identical,<br>            MapPermission::R,<br>        ),<br>        <span class="hljs-literal">None</span>,<br>    );<br>    <span class="hljs-comment">// println!(&quot;mapping .data section&quot;);</span><br>    memory_set.<span class="hljs-title function_ invoke__">push</span>(<br>        MapArea::<span class="hljs-title function_ invoke__">new</span>(<br>            (sdata <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>).<span class="hljs-title function_ invoke__">into</span>(),<br>            (edata <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>).<span class="hljs-title function_ invoke__">into</span>(),<br>            MapType::Identical,<br>            MapPermission::R | MapPermission::W,<br>        ),<br>        <span class="hljs-literal">None</span>,<br>    );<br>    <span class="hljs-comment">// println!(&quot;mapping .bss section&quot;);</span><br>    memory_set.<span class="hljs-title function_ invoke__">push</span>(<br>        MapArea::<span class="hljs-title function_ invoke__">new</span>(<br>            (sbss_with_stack <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>).<span class="hljs-title function_ invoke__">into</span>(),<br>            (ebss <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>).<span class="hljs-title function_ invoke__">into</span>(),<br>            MapType::Identical,<br>            MapPermission::R | MapPermission::W,<br>        ),<br>        <span class="hljs-literal">None</span>,<br>    );<br>    <span class="hljs-comment">// println!(&quot;mapping physical memory&quot;);</span><br>    memory_set.<span class="hljs-title function_ invoke__">push</span>(<br>        MapArea::<span class="hljs-title function_ invoke__">new</span>(<br>            (ekernel <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>).<span class="hljs-title function_ invoke__">into</span>(),<br>            MEMORY_END.<span class="hljs-title function_ invoke__">into</span>(),<br>            MapType::Identical,<br>            MapPermission::R | MapPermission::W,<br>        ),<br>        <span class="hljs-literal">None</span>,<br>    );<br>    <span class="hljs-comment">//println!(&quot;mapping memory-mapped registers&quot;);</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">pair</span> <span class="hljs-keyword">in</span> MMIO &#123;<br>        memory_set.<span class="hljs-title function_ invoke__">push</span>(<br>            MapArea::<span class="hljs-title function_ invoke__">new</span>(<br>                (*pair).<span class="hljs-number">0</span>.<span class="hljs-title function_ invoke__">into</span>(),<br>                ((*pair).<span class="hljs-number">0</span> + (*pair).<span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">into</span>(),<br>                MapType::Identical,<br>                MapPermission::R | MapPermission::W,<br>            ),<br>            <span class="hljs-literal">None</span>,<br>        );<br>    &#125;<br>    memory_set<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="应用地址空间"><a href="#应用地址空间" class="headerlink" title="应用地址空间"></a>应用地址空间</h5><p>应用地址空间是每个进程独立拥有的地址空间，用于存储进程的代码、数据、栈等。每个进程的应用地址空间是相互隔离的，一个进程无法直接访问另一个进程的地址空间，从而保证了系统的安全性和稳定性。在 PotatOS 中，应用地址空间的映射和管理也是通过 <code>PageTable</code> 和 <code>MapArea</code> 来实现的。当创建一个新的进程时，会为其分配一个独立的页表和逻辑段，用于管理其应用地址空间。</p><p><img src="https://rcore-os.cn/rCore-Tutorial-Book-v3/_images/app-as-full.png" alt="..&#x2F;_images&#x2F;app-as-full.png"></p><p>实现了用户空间的统一化之后，我们可以把应用链接到同一个虚拟地址中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs assembly">OUTPUT_ARCH(riscv)<br>ENTRY(_start)<br><br>BASE_ADDRESS = 0x10000;<br><br>SECTIONS<br>&#123;<br>    . = BASE_ADDRESS;<br>    .text : &#123;<br>        *(.text.entry)<br>        *(.text .text.*)<br>    &#125;<br>    . = ALIGN(4K);<br>    .rodata : &#123;<br>        *(.rodata .rodata.*)<br>        *(.srodata .srodata.*)<br>    &#125;<br>    . = ALIGN(4K);<br>    .data : &#123;<br>        *(.data .data.*)<br>        *(.sdata .sdata.*)<br>    &#125;<br>    .bss : &#123;<br>        *(.bss .bss.*)<br>        *(.sbss .sbss.*)<br>    &#125;<br>    /DISCARD/ : &#123;<br>        *(.eh_frame)<br>        *(.debug*)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程可以简单理解为<strong>操作系统对程序进行一次执行的过程</strong></p><p>在<strong>rCore</strong>中，进程被分离成了<code>task</code>和<code>process</code>。process主要指代进程，task主要指代具体执行的任务，可以理解为线程。</p><h3 id="任务模型-Task"><a href="#任务模型-Task" class="headerlink" title="任务模型(Task)"></a>任务模型(Task)</h3><p>任务是操作系统中最小的执行单位，它可以是一个线程或者一个进程中的一部分。任务通常具有自己的执行上下文，包括寄存器状态、栈指针等。在 PotatOS 中，任务的调度和管理是操作系统的重要功能之一，它负责决定哪个任务在何时执行，以提高系统的并发性能和资源利用率。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TaskControlBlock</span> &#123;<br>    <span class="hljs-keyword">pub</span> pid: <span class="hljs-type">usize</span>,<br>    <span class="hljs-keyword">pub</span> ppid: <span class="hljs-type">usize</span>,<br>    <span class="hljs-comment">// immutable</span><br>    <span class="hljs-keyword">pub</span> process: Weak&lt;ProcessControlBlock&gt;,<br>    <span class="hljs-keyword">pub</span> kstack: KernelStack,<br>    <span class="hljs-comment">// mutable</span><br>    <span class="hljs-keyword">pub</span> inner: UPIntrFreeCell&lt;TaskControlBlockInner&gt;,<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TaskControlBlockInner</span> &#123;<br>    <span class="hljs-keyword">pub</span> res: <span class="hljs-type">Option</span>&lt;TaskUserRes&gt;,<br>    <span class="hljs-keyword">pub</span> trap_cx_ppn: PhysPageNum,<br>    <span class="hljs-keyword">pub</span> task_cx: TaskContext,<br>    <span class="hljs-keyword">pub</span> task_status: TaskStatus,<br>    <span class="hljs-keyword">pub</span> exit_code: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt;,<br><br>    <span class="hljs-keyword">pub</span> user_time: <span class="hljs-type">usize</span>,<br>    <span class="hljs-keyword">pub</span> kernel_time: <span class="hljs-type">usize</span>,<br>    <span class="hljs-keyword">pub</span> time_created: <span class="hljs-type">usize</span>,    <br>    <span class="hljs-keyword">pub</span> first_time: <span class="hljs-type">usize</span>,<br>    <span class="hljs-keyword">pub</span> stop_watch: <span class="hljs-type">usize</span>,<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>TCB</code>：任务的控制块，包含任务基本信息<ul><li><code>pid</code>：任务所属进程id</li><li><code>ppid</code>：同理，父进程id</li></ul></li><li><code>TCBInner</code>：任务内部信息，包括很多信息，可以通过互斥访问得到<ul><li><code>res</code>：返回状态</li><li><code>cx</code>：任务的上下文，主要包括返回地址，栈顶位置和被调用者寄存器</li><li><code>time</code>：任务的各种时间记录</li></ul></li></ul><p><strong>重要方法</strong>：</p><p>主要是各种时间状态的设置，比如在trap时开启计时，下一个trap时停止当计时；</p><p>以及任务的调度。会在下面统一讲述。</p><h3 id="进程模型-Process"><a href="#进程模型-Process" class="headerlink" title="进程模型(Process)"></a>进程模型(Process)</h3><p>主要由<code>PCB</code>构成</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ProcessControlBlock</span> &#123;<br>    <span class="hljs-comment">// immutable</span><br>    <span class="hljs-keyword">pub</span> pid: PidHandle,<br>    <span class="hljs-comment">// mutable</span><br>    inner: UPIntrFreeCell&lt;ProcessControlBlockInner&gt;,<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ProcessControlBlockInner</span> &#123;<br>    <span class="hljs-keyword">pub</span> is_zombie: <span class="hljs-type">bool</span>,<br>    <span class="hljs-keyword">pub</span> memory_set: MemorySet,<br>    <span class="hljs-keyword">pub</span> parent: <span class="hljs-type">Option</span>&lt;Weak&lt;ProcessControlBlock&gt;&gt;,<br>    <span class="hljs-keyword">pub</span> children: <span class="hljs-type">Vec</span>&lt;Arc&lt;ProcessControlBlock&gt;&gt;,<br>    <span class="hljs-keyword">pub</span> exit_code: <span class="hljs-type">i32</span>,<br>    <span class="hljs-keyword">pub</span> fd_table: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Option</span>&lt;Arc&lt;<span class="hljs-keyword">dyn</span> File + <span class="hljs-built_in">Send</span> + <span class="hljs-built_in">Sync</span>&gt;&gt;&gt;,<br>    <span class="hljs-keyword">pub</span> signals: SignalFlags,<br>    <span class="hljs-keyword">pub</span> tasks: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt;&gt;,<br>    <span class="hljs-keyword">pub</span> task_res_allocator: RecycleAllocator,<br>    <span class="hljs-keyword">pub</span> mutex_list: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Option</span>&lt;Arc&lt;<span class="hljs-keyword">dyn</span> Mutex&gt;&gt;&gt;,<br>    <span class="hljs-keyword">pub</span> semaphore_list: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Option</span>&lt;Arc&lt;Semaphore&gt;&gt;&gt;,<br>    <span class="hljs-keyword">pub</span> condvar_list: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Option</span>&lt;Arc&lt;Condvar&gt;&gt;&gt;,<br><br>    <span class="hljs-keyword">pub</span> cwd: Arc&lt;Inode&gt;,<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>ProcessControlBlock</code>：进程控制块结构体，包含进程的基本信息和可变部分。<ul><li><code>pid</code>：进程标识符，用于唯一标识一个进程。</li><li><code>inner</code>：可变部分，使用 <code>UPIntrFreeCell</code> 进行封装，确保线程安全。</li></ul></li><li><code>ProcessControlBlockInner</code>：进程控制块的可变部分，包含了进程的详细信息。<ul><li><code>is_zombie</code>：表示进程是否为僵尸进程。僵尸进程是指已经结束但尚未被父进程回收的进程。</li><li><code>memory_set</code>：进程的地址空间，包含了进程的页表和逻辑段。</li><li><code>parent</code>：父进程的弱引用，用于表示进程之间的父子关系。</li><li><code>children</code>：子进程的强引用列表，存储了该进程的所有子进程。</li><li><code>exit_code</code>：进程的退出码，用于表示进程的退出状态。</li><li><code>fd_table</code>：文件描述符表，存储了进程打开的文件的引用。</li><li><code>signals</code>：信号标志，用于处理进程接收到的信号。</li><li><code>tasks</code>：任务列表，存储了进程中的所有任务。</li><li><code>task_res_allocator</code>：任务资源分配器，用于分配和回收任务的资源。</li><li><code>mutex_list</code>：互斥锁列表，用于实现进程内的互斥访问。</li><li><code>semaphore_list</code>：信号量列表，用于实现进程间的同步和互斥。</li><li><code>condvar_list</code>：条件变量列表，用于实现进程间的同步和通信。</li><li><code>cwd</code>：当前工作目录的索引节点，用于指定进程的当前工作目录。</li></ul></li></ul><p><strong>重要方法</strong>：</p><ul><li><code>fork</code>：除了初始进程外，通用的进程产生方法。除了 pid 外，child 继承 parent 大部分信息。<code>fork</code> 系统调用会创建一个新的进程，该进程是调用进程的副本，拥有相同的代码、数据和文件描述符等。新进程的 pid 是唯一的，与父进程不同。</li><li><code>exec</code>：将当前进程的地址空间清空并加载一个特定的可执行文件，返回用户态后开始它的执行。<code>exec</code> 系统调用会用新的可执行文件替换当前进程的地址空间，从而使进程执行新的程序。</li><li><code>waitpid</code>：当前进程等待一个子进程变为僵尸进程，回收其全部资源并收集其返回值。<code>waitpid</code> 系统调用会阻塞当前进程，直到指定的子进程结束并变为僵尸进程，然后回收子进程的资源，并获取其退出码。</li></ul><h4 id="initproc"><a href="#initproc" class="headerlink" title="initproc"></a>initproc</h4><p>初始进程，所有进程都从它 fork 出来。这里的实现是直接 fork 出一个<strong>user_shell</strong>进程。<code>initproc</code> 是操作系统启动后的第一个进程，它负责创建其他进程和初始化系统环境。在 PotatOS 中，<code>initproc</code> 会 fork 出一个 <code>user_shell</code> 进程，用于提供用户交互界面。</p><h4 id="user-shell"><a href="#user-shell" class="headerlink" title="user_shell"></a>user_shell</h4><p>一个简单的 shell 程序，负责执行内部命令和外部命令。</p><ul><li><strong>内部命令</strong>：关系到当前主进程，需要改变其状态的命令。比如<code>pwd</code>，<code>chdir</code>等等。内部命令通常是由 shell 本身实现的，不需要创建新的进程来执行。</li><li><strong>外部命令</strong>：执行系统外部的程序，简单地 fork 后 exec。外部命令是指需要执行系统中其他可执行文件的命令，shell 会创建一个新的进程来执行这些命令。</li></ul><h3 id="进程执行"><a href="#进程执行" class="headerlink" title="进程执行"></a>进程执行</h3><h4 id="应用的链接与加载"><a href="#应用的链接与加载" class="headerlink" title="应用的链接与加载"></a>应用的链接与加载</h4><p>在<code>Make</code>启动 Qemu 时，user&#x2F;src&#x2F;bin&#x2F; 内的程序会通过<strong>efs-fuse</strong>被预加载到 fs.img 中。详见下文。如果不使用 efs-fuse，则需要使用<strong>link_app.S</strong>把编译后的文件一个个加载到内存的地址中。这种硬编码的形式令人难受。</p><p><code>efs-fuse</code> 是一个用户空间的文件系统，它可以将 user&#x2F;src&#x2F;bin&#x2F; 目录下的所有程序二进制格式打包，并加载到预先准备好的 fs.img 中。这样，在启动 Qemu 时，操作系统可以直接从 fs.img 中读取这些程序，并加载到内存中执行。而使用 <code>link_app.S</code> 则需要手动将编译后的文件加载到内存的指定地址，这种方式比较繁琐，而且容易出错。</p><h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>进程的调度基于<strong>任务调度</strong>。任务调度是操作系统的核心功能之一，它负责决定哪个任务在何时执行，以提高系统的并发性能和资源利用率。在PotatOS中，任务调度使用简单的RR时间片方法。</p><h4 id="调度方法"><a href="#调度方法" class="headerlink" title="调度方法"></a>调度方法</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// os/src/task/manager.rs</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TaskManager</span> &#123;<br>    ready_queue: VecDeque&lt;Arc&lt;TaskControlBlock&gt;&gt;,<br>&#125;<br><br><span class="hljs-comment">/// A simple FIFO scheduler.</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">TaskManager</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">Self</span> &#123;<br>            ready_queue: VecDeque::<span class="hljs-title function_ invoke__">new</span>(),<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, task: Arc&lt;TaskControlBlock&gt;) &#123;<br>        <span class="hljs-keyword">self</span>.ready_queue.<span class="hljs-title function_ invoke__">push_back</span>(task);<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fetch</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt; &#123;<br>        <span class="hljs-keyword">self</span>.ready_queue.<span class="hljs-title function_ invoke__">pop_front</span>()<br>    &#125;<br>&#125;<br><br>lazy_static! &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">ref</span> TASK_MANAGER: UPIntrFreeCell&lt;TaskManager&gt; =<br>        <span class="hljs-keyword">unsafe</span> &#123; UPIntrFreeCell::<span class="hljs-title function_ invoke__">new</span>(TaskManager::<span class="hljs-title function_ invoke__">new</span>()) &#125;;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">ref</span> PID2PCB: UPIntrFreeCell&lt;BTreeMap&lt;<span class="hljs-type">usize</span>, Arc&lt;ProcessControlBlock&gt;&gt;&gt; =<br>        <span class="hljs-keyword">unsafe</span> &#123; UPIntrFreeCell::<span class="hljs-title function_ invoke__">new</span>(BTreeMap::<span class="hljs-title function_ invoke__">new</span>()) &#125;;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_task</span>(task: Arc&lt;TaskControlBlock&gt;) &#123;<br>    TASK_MANAGER.<span class="hljs-title function_ invoke__">exclusive_access</span>(<span class="hljs-built_in">file!</span>(), <span class="hljs-built_in">line!</span>()).<span class="hljs-title function_ invoke__">add</span>(task);<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">wakeup_task</span>(task: Arc&lt;TaskControlBlock&gt;) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">task_inner</span> = task.<span class="hljs-title function_ invoke__">inner_exclusive_access</span>(<span class="hljs-built_in">file!</span>(), <span class="hljs-built_in">line!</span>());<br>    task_inner.task_status = TaskStatus::Ready;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">task_info</span> = TaskInfo &#123;<br>        pid: task.<span class="hljs-title function_ invoke__">get_pid</span>(),<br>        ppid: task.<span class="hljs-title function_ invoke__">get_ppid</span>(), <br>        status: task_inner.task_status,<br>        user_time: task_inner.user_time,<br>        kernel_time: task_inner.kernel_time,<br>        time_created: task_inner.time_created,<br>        first_time: task_inner.first_time,<br>    &#125;;<br>    <br>    <span class="hljs-title function_ invoke__">drop</span>(task_inner);<br>    <span class="hljs-title function_ invoke__">add_task</span>(task);<br>    <br>    <span class="hljs-title function_ invoke__">write_proc</span>(task_info);<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fetch_task</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt; &#123;<br>    TASK_MANAGER.<span class="hljs-title function_ invoke__">exclusive_access</span>(<span class="hljs-built_in">file!</span>(), <span class="hljs-built_in">line!</span>()).<span class="hljs-title function_ invoke__">fetch</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>任务的调度由简单的<strong>FIFO队列</strong>实现。主要包括一下几个方法：</p><ul><li><code>add_task</code>：直接往队列里加入task</li><li><code>wakeup_task</code>：把一个新的task唤醒，然后插入到proces队列里</li><li><code>fetch_task</code>：取得一个task</li></ul><h4 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h4><p>在内核里，我们设置了一个timer类，用于时间片轮转方法。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// os/src/timer.rs</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_time</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    time::<span class="hljs-title function_ invoke__">read</span>()<br>&#125;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_time_ms</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    time::<span class="hljs-title function_ invoke__">read</span>() / (CLOCK_FREQ / MSEC_PER_SEC)<br>&#125;<br><span class="hljs-comment">/// set time slice for current task</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">set_next_trigger</span>() &#123;<br>    <span class="hljs-title function_ invoke__">set_timer</span>(<span class="hljs-title function_ invoke__">get_time</span>() + CLOCK_FREQ / TICKS_PER_SEC);<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_timer</span>(expire_ms: <span class="hljs-type">usize</span>, task: Arc&lt;TaskControlBlock&gt;) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">timers</span> = TIMERS.<span class="hljs-title function_ invoke__">exclusive_access</span>(<span class="hljs-built_in">file!</span>(), <span class="hljs-built_in">line!</span>());<br>    timers.<span class="hljs-title function_ invoke__">push</span>(TimerCondVar &#123; expire_ms, task &#125;);<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">check_timer</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">current_ms</span> = <span class="hljs-title function_ invoke__">get_time_ms</span>();<br>    TIMERS.<span class="hljs-title function_ invoke__">exclusive_session</span>(|timers| &#123;<br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(timer) = timers.<span class="hljs-title function_ invoke__">peek</span>() &#123;<br>            <span class="hljs-keyword">if</span> timer.expire_ms &lt;= current_ms &#123;<br>                <span class="hljs-title function_ invoke__">wakeup_task</span>(Arc::<span class="hljs-title function_ invoke__">clone</span>(&amp;timer.task));<br>                timers.<span class="hljs-title function_ invoke__">pop</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;);<br>&#125;<br><br><span class="hljs-comment">// os/src/sbi.rs</span><br><span class="hljs-comment">/// use sbi call to set timer</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">set_timer</span>(timer: <span class="hljs-type">usize</span>) &#123;<br>    sbi_rt::<span class="hljs-title function_ invoke__">set_timer</span>(timer <span class="hljs-keyword">as</span> _);<br>&#125;<br><br><span class="hljs-comment">// os/src/trap/mod.rs</span><br>Trap::<span class="hljs-title function_ invoke__">Interrupt</span>(Interrupt::SupervisorTimer) =&gt; &#123;<br>    <span class="hljs-title function_ invoke__">set_next_trigger</span>();<br>    <span class="hljs-title function_ invoke__">check_timer</span>();<br>    <span class="hljs-comment">// do not schedule now</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里的关键就是通过<code>set_timer</code>可以为<strong>RISC-V</strong>设置一个定时的中断，触发后进入时钟的中断处理。</p><p>中断处理就是简单地对时钟队列进行调度并设置下一个时间片。</p><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// os/src/task/processor.rs</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Processor</span> &#123;<br>    current: <span class="hljs-type">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt;,<br>    idle_task_cx: TaskContext,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Processor</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">Self</span> &#123;<br>            current: <span class="hljs-literal">None</span>,<br>            idle_task_cx: TaskContext::<span class="hljs-title function_ invoke__">zero_init</span>(),<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_idle_task_cx_ptr</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> *<span class="hljs-keyword">mut</span> TaskContext &#123;<br>        &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.idle_task_cx <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> _<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">take_current</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt; &#123;<br>        <span class="hljs-keyword">self</span>.current.<span class="hljs-title function_ invoke__">take</span>()<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">current</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt; &#123;<br>        <span class="hljs-keyword">self</span>.current.<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">map</span>(Arc::clone)<br>    &#125;<br>&#125;<br><br>lazy_static! &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">ref</span> PROCESSOR: UPIntrFreeCell&lt;Processor&gt; =<br>        <span class="hljs-keyword">unsafe</span> &#123; UPIntrFreeCell::<span class="hljs-title function_ invoke__">new</span>(Processor::<span class="hljs-title function_ invoke__">new</span>()) &#125;;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">run_tasks</span>() &#123;<br>    <span class="hljs-keyword">loop</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">processor</span> = PROCESSOR.<span class="hljs-title function_ invoke__">exclusive_access</span>(<span class="hljs-built_in">file!</span>(), <span class="hljs-built_in">line!</span>());<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(task) = <span class="hljs-title function_ invoke__">fetch_task</span>() &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">idle_task_cx_ptr</span> = processor.<span class="hljs-title function_ invoke__">get_idle_task_cx_ptr</span>();<br>            <span class="hljs-comment">// access coming task TCB exclusively</span><br>            <span class="hljs-keyword">let</span> (next_task_cx_ptr, task_info) = task.inner.<span class="hljs-title function_ invoke__">exclusive_session</span>(|task_inner| &#123;<br>                task_inner.task_status = TaskStatus::Running;<br>                task_inner.first_time = <span class="hljs-title function_ invoke__">get_time_ms</span>();<br>                task_inner.<span class="hljs-title function_ invoke__">refresh_watch</span>();<br>                (&amp;task_inner.task_cx <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> TaskContext, <br>                TaskInfo &#123;<br>                    pid: task.<span class="hljs-title function_ invoke__">get_pid</span>(),<br>                    ppid: task.<span class="hljs-title function_ invoke__">get_ppid</span>(),<br>                    status: task_inner.task_status,<br>                    user_time: task_inner.user_time,<br>                    kernel_time: task_inner.kernel_time,<br>                    time_created: task_inner.time_created,<br>                    first_time: task_inner.first_time,<br>                &#125;)<br>            &#125;);<br>            processor.current = <span class="hljs-title function_ invoke__">Some</span>(task);<br>            <span class="hljs-comment">// release processor manually</span><br>            <span class="hljs-title function_ invoke__">drop</span>(processor);<br>            <span class="hljs-title function_ invoke__">write_proc</span>(task_info);<br>            <span class="hljs-keyword">unsafe</span> &#123;<br>                __switch(idle_task_cx_ptr, next_task_cx_ptr);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;no tasks available in run_tasks&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">take_current_task</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt; &#123;<br>    PROCESSOR.<span class="hljs-title function_ invoke__">exclusive_access</span>(<span class="hljs-built_in">file!</span>(), <span class="hljs-built_in">line!</span>()).<span class="hljs-title function_ invoke__">take_current</span>()<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">current_task</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;Arc&lt;TaskControlBlock&gt;&gt; &#123;<br>    PROCESSOR.<span class="hljs-title function_ invoke__">exclusive_access</span>(<span class="hljs-built_in">file!</span>(), <span class="hljs-built_in">line!</span>()).<span class="hljs-title function_ invoke__">current</span>()<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">current_process</span>() <span class="hljs-punctuation">-&gt;</span> Arc&lt;ProcessControlBlock&gt; &#123;<br>    <span class="hljs-title function_ invoke__">current_task</span>().<span class="hljs-title function_ invoke__">unwrap</span>().process.<span class="hljs-title function_ invoke__">upgrade</span>().<span class="hljs-title function_ invoke__">unwrap</span>()<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">current_user_token</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">task</span> = <span class="hljs-title function_ invoke__">current_task</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    task.<span class="hljs-title function_ invoke__">get_user_token</span>()<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">current_trap_cx</span>() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-keyword">mut</span> TrapContext &#123;<br>    <span class="hljs-title function_ invoke__">current_task</span>()<br>        .<span class="hljs-title function_ invoke__">unwrap</span>()<br>        .<span class="hljs-title function_ invoke__">inner_exclusive_access</span>(<span class="hljs-built_in">file!</span>(), <span class="hljs-built_in">line!</span>())<br>        .<span class="hljs-title function_ invoke__">get_trap_cx</span>()<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">current_trap_cx_user_va</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    <span class="hljs-title function_ invoke__">current_task</span>()<br>        .<span class="hljs-title function_ invoke__">unwrap</span>()<br>        .<span class="hljs-title function_ invoke__">inner_exclusive_access</span>(<span class="hljs-built_in">file!</span>(), <span class="hljs-built_in">line!</span>())<br>        .res<br>        .<span class="hljs-title function_ invoke__">as_ref</span>()<br>        .<span class="hljs-title function_ invoke__">unwrap</span>()<br>        .<span class="hljs-title function_ invoke__">trap_cx_user_va</span>()<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">current_kstack_top</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    <span class="hljs-title function_ invoke__">current_task</span>().<span class="hljs-title function_ invoke__">unwrap</span>().kstack.<span class="hljs-title function_ invoke__">get_top</span>()<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">schedule</span>(switched_task_cx_ptr: *<span class="hljs-keyword">mut</span> TaskContext) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">idle_task_cx_ptr</span> =<br>        PROCESSOR.<span class="hljs-title function_ invoke__">exclusive_session</span>(|processor| processor.<span class="hljs-title function_ invoke__">get_idle_task_cx_ptr</span>());<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        __switch(switched_task_cx_ptr, idle_task_cx_ptr);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>调度方式就是从<strong>FIFO就绪队列</strong>里获得最新的进程，进行上下文切换执行</p><h3 id="进程同步机制"><a href="#进程同步机制" class="headerlink" title="进程同步机制"></a>进程同步机制</h3><p>进程同步机制实际上是进程对<strong>Critical Section</strong>的<strong>受限访问</strong>，因此塞到进程一栏。</p><h4 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h4><p>mutex包括了<strong>自旋锁</strong>和<strong>阻塞锁</strong>，实现如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Mutex</span>: <span class="hljs-built_in">Sync</span> + <span class="hljs-built_in">Send</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">lock</span>(&amp;<span class="hljs-keyword">self</span>);<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">unlock</span>(&amp;<span class="hljs-keyword">self</span>);<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">MutexSpin</span> &#123;<br>    locked: UPIntrFreeCell&lt;<span class="hljs-type">bool</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">MutexSpin</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">Self</span> &#123;<br>            locked: <span class="hljs-keyword">unsafe</span> &#123; UPIntrFreeCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">false</span>) &#125;,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Mutex</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">MutexSpin</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">lock</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">loop</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">locked</span> = <span class="hljs-keyword">self</span>.locked.<span class="hljs-title function_ invoke__">exclusive_access</span>(<span class="hljs-built_in">file!</span>(), <span class="hljs-built_in">line!</span>());<br>            <span class="hljs-keyword">if</span> *locked &#123;<br>                <span class="hljs-title function_ invoke__">drop</span>(locked);<br>                <span class="hljs-title function_ invoke__">suspend_current_and_run_next</span>();<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                *locked = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">unlock</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">locked</span> = <span class="hljs-keyword">self</span>.locked.<span class="hljs-title function_ invoke__">exclusive_access</span>(<span class="hljs-built_in">file!</span>(), <span class="hljs-built_in">line!</span>());<br>        *locked = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">MutexBlocking</span> &#123;<br>    inner: UPIntrFreeCell&lt;MutexBlockingInner&gt;,<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">MutexBlockingInner</span> &#123;<br>    locked: <span class="hljs-type">bool</span>,<br>    wait_queue: VecDeque&lt;Arc&lt;TaskControlBlock&gt;&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">MutexBlocking</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">Self</span> &#123;<br>            inner: <span class="hljs-keyword">unsafe</span> &#123;<br>                UPIntrFreeCell::<span class="hljs-title function_ invoke__">new</span>(MutexBlockingInner &#123;<br>                    locked: <span class="hljs-literal">false</span>,<br>                    wait_queue: VecDeque::<span class="hljs-title function_ invoke__">new</span>(),<br>                &#125;)<br>            &#125;,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Mutex</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">MutexBlocking</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">lock</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">mutex_inner</span> = <span class="hljs-keyword">self</span>.inner.<span class="hljs-title function_ invoke__">exclusive_access</span>(<span class="hljs-built_in">file!</span>(), <span class="hljs-built_in">line!</span>());<br>        <span class="hljs-keyword">if</span> mutex_inner.locked &#123;<br>            mutex_inner.wait_queue.<span class="hljs-title function_ invoke__">push_back</span>(<span class="hljs-title function_ invoke__">current_task</span>().<span class="hljs-title function_ invoke__">unwrap</span>());<br>            <span class="hljs-title function_ invoke__">drop</span>(mutex_inner);<br>            <span class="hljs-title function_ invoke__">block_current_and_run_next</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mutex_inner.locked = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">unlock</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">mutex_inner</span> = <span class="hljs-keyword">self</span>.inner.<span class="hljs-title function_ invoke__">exclusive_access</span>(<span class="hljs-built_in">file!</span>(), <span class="hljs-built_in">line!</span>());<br>        <span class="hljs-built_in">assert!</span>(mutex_inner.locked);<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(waking_task) = mutex_inner.wait_queue.<span class="hljs-title function_ invoke__">pop_front</span>() &#123;<br>            <span class="hljs-title function_ invoke__">wakeup_task</span>(waking_task);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mutex_inner.locked = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>自旋锁主要是使用了一块互斥访问的Bool区域，用于上锁</p><p>阻塞类型的锁与<strong>进程</strong>结合，实现了简单的阻塞队列</p><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Condvar</span> &#123;<br>    <span class="hljs-keyword">pub</span> inner: UPIntrFreeCell&lt;CondvarInner&gt;,<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CondvarInner</span> &#123;<br>    <span class="hljs-keyword">pub</span> wait_queue: VecDeque&lt;Arc&lt;TaskControlBlock&gt;&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Condvar</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">Self</span> &#123;<br>            inner: <span class="hljs-keyword">unsafe</span> &#123;<br>                UPIntrFreeCell::<span class="hljs-title function_ invoke__">new</span>(CondvarInner &#123;<br>                    wait_queue: VecDeque::<span class="hljs-title function_ invoke__">new</span>(),<br>                &#125;)<br>            &#125;,<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">signal</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">inner</span> = <span class="hljs-keyword">self</span>.inner.<span class="hljs-title function_ invoke__">exclusive_access</span>(<span class="hljs-built_in">file!</span>(), <span class="hljs-built_in">line!</span>());<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(task) = inner.wait_queue.<span class="hljs-title function_ invoke__">pop_front</span>() &#123;<br>            <span class="hljs-title function_ invoke__">wakeup_task</span>(task);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">wait_no_sched</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> *<span class="hljs-keyword">mut</span> TaskContext &#123;<br>        <span class="hljs-keyword">self</span>.inner.<span class="hljs-title function_ invoke__">exclusive_session</span>(|inner| &#123;<br>            inner.wait_queue.<span class="hljs-title function_ invoke__">push_back</span>(<span class="hljs-title function_ invoke__">current_task</span>().<span class="hljs-title function_ invoke__">unwrap</span>());<br>        &#125;);<br>        <span class="hljs-title function_ invoke__">block_current_task</span>()<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">wait_with_mutex</span>(&amp;<span class="hljs-keyword">self</span>, mutex: Arc&lt;<span class="hljs-keyword">dyn</span> Mutex&gt;) &#123;<br>        mutex.<span class="hljs-title function_ invoke__">unlock</span>();<br>        <span class="hljs-keyword">self</span>.inner.<span class="hljs-title function_ invoke__">exclusive_session</span>(|inner| &#123;<br>            inner.wait_queue.<span class="hljs-title function_ invoke__">push_back</span>(<span class="hljs-title function_ invoke__">current_task</span>().<span class="hljs-title function_ invoke__">unwrap</span>());<br>        &#125;);<br>        <span class="hljs-title function_ invoke__">block_current_and_run_next</span>();<br>        mutex.<span class="hljs-title function_ invoke__">lock</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>条件变量主要是<strong>上锁</strong>和<strong>唤醒</strong>。</p><h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Semaphore</span> &#123;<br>    <span class="hljs-keyword">pub</span> inner: UPIntrFreeCell&lt;SemaphoreInner&gt;,<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SemaphoreInner</span> &#123;<br>    <span class="hljs-keyword">pub</span> count: <span class="hljs-type">isize</span>,<br>    <span class="hljs-keyword">pub</span> wait_queue: VecDeque&lt;Arc&lt;TaskControlBlock&gt;&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Semaphore</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(res_count: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">Self</span> &#123;<br>            inner: <span class="hljs-keyword">unsafe</span> &#123;<br>                UPIntrFreeCell::<span class="hljs-title function_ invoke__">new</span>(SemaphoreInner &#123;<br>                    count: res_count <span class="hljs-keyword">as</span> <span class="hljs-type">isize</span>,<br>                    wait_queue: VecDeque::<span class="hljs-title function_ invoke__">new</span>(),<br>                &#125;)<br>            &#125;,<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">up</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">inner</span> = <span class="hljs-keyword">self</span>.inner.<span class="hljs-title function_ invoke__">exclusive_access</span>(<span class="hljs-built_in">file!</span>(), <span class="hljs-built_in">line!</span>());<br>        inner.count += <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> inner.count &lt;= <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(task) = inner.wait_queue.<span class="hljs-title function_ invoke__">pop_front</span>() &#123;<br>                <span class="hljs-title function_ invoke__">wakeup_task</span>(task);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">down</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">inner</span> = <span class="hljs-keyword">self</span>.inner.<span class="hljs-title function_ invoke__">exclusive_access</span>(<span class="hljs-built_in">file!</span>(), <span class="hljs-built_in">line!</span>());<br>        inner.count -= <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> inner.count &lt; <span class="hljs-number">0</span> &#123;<br>            inner.wait_queue.<span class="hljs-title function_ invoke__">push_back</span>(<span class="hljs-title function_ invoke__">current_task</span>().<span class="hljs-title function_ invoke__">unwrap</span>());<br>            <span class="hljs-title function_ invoke__">drop</span>(inner);<br>            <span class="hljs-title function_ invoke__">block_current_and_run_next</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>信号量相当于<em>资源池</em>，限制了进程的并发量。</p><p>实现也比较简单。</p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>本系统模仿使用了<strong>easyfs</strong>，一个简化版本的文件系统。为了降低耦合性，整体可以分为五层：</p><ol><li><strong>磁盘块接口层</strong>：抽象封装磁盘块，实现对外接口。该层提供了对磁盘块的基本读写操作，是文件系统与磁盘设备之间的接口。</li><li><strong>块缓存层</strong>：实现块缓存功能，提供对外读写接口。为了提高文件系统的读写性能，该层引入了块缓存机制，将经常访问的磁盘块缓存到内存中，减少了磁盘的读写次数。</li><li><strong>磁盘块数据结构层</strong>：实现 superblock，datablock，inode 等等。该层定义了文件系统的基本数据结构，如超级块、数据块、索引节点等，用于管理文件和目录的存储。</li><li><strong>磁盘块管理层</strong>：easyfs 的主要部分，进行块的管理。该层负责磁盘块的分配和回收，确保文件系统能够高效地利用磁盘空间。</li><li><strong>索引节点层</strong>：inode 实现文件读写管理功能，封装后可以提供对外接口读写。该层通过索引节点来管理文件和目录的读写操作，为上层的操作系统提供了统一的文件访问接口。</li></ol><p>通过 VFS 和 File trait 封装整个 easyfs 的 inode，为上层的 OS 提供接口。最后通过 VirtIO 模拟块设备驱动，搭载到 qemu 模拟器上面。</p><h3 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h3><h4 id="块设备接口层"><a href="#块设备接口层" class="headerlink" title="块设备接口层"></a>块设备接口层</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">BlockDevice</span>: <span class="hljs-built_in">Send</span> + <span class="hljs-built_in">Sync</span> + Any &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_block</span>(&amp;<span class="hljs-keyword">self</span>, block_id: <span class="hljs-type">usize</span>, buf: &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">u8</span>]);<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write_block</span>(&amp;<span class="hljs-keyword">self</span>, block_id: <span class="hljs-type">usize</span>, buf: &amp;[<span class="hljs-type">u8</span>]);<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">handle_irq</span>(&amp;<span class="hljs-keyword">self</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>实现了读写块和处理中断的功能。该接口定义了块设备的基本操作，包括读取磁盘块、写入磁盘块和处理中断。任何实现了该接口的类型都可以作为块设备使用。</p><h4 id="块缓存层"><a href="#块缓存层" class="headerlink" title="块缓存层"></a>块缓存层</h4><p>为了应对频繁的读写采用缓存加速。</p><p><strong>块缓存</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BlockCache</span> &#123;<br>    cache: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u8</span>&gt;,<br>    block_id: <span class="hljs-type">usize</span>,<br>    block_device: Arc&lt;<span class="hljs-keyword">dyn</span> BlockDevice&gt;,<br>    modified: <span class="hljs-type">bool</span>,<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>cache</code>：缓存字节记录，用于存储磁盘块的内容。</li><li><code>block_id</code>，<code>block_device</code>：块设备以及块地址，用于标识缓存的磁盘块。</li><li><code>modified</code>：脏标记，采用懒更新方式刷入磁盘。如果该标记为 <code>true</code>，表示缓存中的数据已经被修改，需要在适当的时候将其写回磁盘。</li></ul><p>提供了基本的读写和同步刷盘方法。可通过<code>get_block_cache</code>取得，通过传递一个闭包实现对应的方法和访问功能。块缓存的读写操作会先在缓存中查找，如果缓存中存在所需的数据，则直接从缓存中读取；如果缓存中不存在，则从磁盘中读取并更新缓存。同步刷盘方法会将缓存中被修改的数据写回磁盘。</p><p><strong>块缓存管理</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">const</span> BLOCK_CACHE_SIZE: <span class="hljs-type">usize</span> = <span class="hljs-number">16</span>;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BlockCacheManager</span> &#123;<br>    queue: VecDeque&lt;(<span class="hljs-type">usize</span>, Arc&lt;Mutex&lt;BlockCache&gt;&gt;)&gt;,<br>&#125;<br></code></pre></td></tr></table></figure><p>一个简单的缓存管理结构，实现了 LRU出入队和读写、同步方法。该管理器使用一个双端队列来维护缓存块的访问顺序，最近访问的缓存块会被移动到队列的头部，当缓存满时，会将队列尾部的缓存块淘汰。</p><h3 id="EasyFS"><a href="#EasyFS" class="headerlink" title="EasyFS"></a>EasyFS</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>基本结构如图所示</p><h4 id="超级块"><a href="#超级块" class="headerlink" title="超级块"></a>超级块</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SuperBlock</span> &#123;<br>    magic: <span class="hljs-type">u32</span>,<br>    <span class="hljs-keyword">pub</span> total_blocks: <span class="hljs-type">u32</span>,<br>    <span class="hljs-keyword">pub</span> inode_bitmap_blocks: <span class="hljs-type">u32</span>,<br>    <span class="hljs-keyword">pub</span> inode_area_blocks: <span class="hljs-type">u32</span>,<br>    <span class="hljs-keyword">pub</span> data_bitmap_blocks: <span class="hljs-type">u32</span>,<br>    <span class="hljs-keyword">pub</span> data_area_blocks: <span class="hljs-type">u32</span>,<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>magic</code>：文件系统检查的魔数，用于标识文件系统的类型。</li><li><code>total_blocks</code>：文件系统的总块数，即磁盘上可用的总块数。</li><li><code>****_blocks</code>：给出了各个区域的块数，包括 inode 位图块数、inode 区域块数、数据位图块数和数据区域块数。</li></ul><p>超级块实现了<code>debug</code>方法，即检查各部分块数，以及文件系统的检查，判定是否为EFS</p><h4 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">const</span> BLOCK_BITS: <span class="hljs-type">usize</span> = BLOCK_SZ * <span class="hljs-number">8</span>;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Bitmap</span> &#123;<br>    start_block_id: <span class="hljs-type">usize</span>,<br>    blocks: <span class="hljs-type">usize</span>,<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>start_block_id</code>：当前 bitmap 起始位置，即位图所管理的第一个磁盘块的编号。</li><li><code>blocks</code>：bitmap 管理了多少块，即位图所管理的磁盘块的数量。</li></ul><p>bitmap 实现了基本的分配功能，包括分配和释放块时位图的改变。这里通过简单的线性遍历进行空块判断。当需要分配一个磁盘块时，位图会从起始位置开始线性遍历，找到第一个未被使用的块，并将其标记为已使用；当需要释放一个磁盘块时，位图会将该块标记为未使用。</p><h4 id="DiskInode"><a href="#DiskInode" class="headerlink" title="DiskInode"></a>DiskInode</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">const</span> INODE_DIRECT_COUNT: <span class="hljs-type">usize</span> = <span class="hljs-number">27</span>;<br><span class="hljs-keyword">const</span> INODE_INDIRECT1_COUNT: <span class="hljs-type">usize</span> = BLOCK_SZ / <span class="hljs-number">4</span>;<br><span class="hljs-keyword">const</span> INODE_INDIRECT2_COUNT: <span class="hljs-type">usize</span> = INODE_INDIRECT1_COUNT * INODE_INDIRECT1_COUNT;<br><span class="hljs-keyword">const</span> INODE_INDIRECT3_COUNT: <span class="hljs-type">usize</span> = INODE_INDIRECT2_COUNT * INODE_INDIRECT1_COUNT;<br><span class="hljs-keyword">const</span> DIRECT_BOUND: <span class="hljs-type">usize</span> = INODE_DIRECT_COUNT;<br><span class="hljs-keyword">const</span> INDIRECT1_BOUND: <span class="hljs-type">usize</span> = DIRECT_BOUND + INODE_INDIRECT1_COUNT;<br><span class="hljs-keyword">const</span> INDIRECT2_BOUND: <span class="hljs-type">usize</span> = INDIRECT1_BOUND + INODE_INDIRECT2_COUNT;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">DiskInodeType</span> &#123;<br>    File,<br>    Directory,<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DiskInode</span> &#123;<br>    <span class="hljs-keyword">pub</span> size: <span class="hljs-type">u32</span>,<br>    <span class="hljs-keyword">pub</span> direct: [<span class="hljs-type">u32</span>; INODE_DIRECT_COUNT],<br>    <span class="hljs-keyword">pub</span> indirect1: <span class="hljs-type">u32</span>,<br>    <span class="hljs-keyword">pub</span> indirect2: <span class="hljs-type">u32</span>,<br>    <span class="hljs-keyword">pub</span> indirect3: <span class="hljs-type">u32</span>,<br>    type_: DiskInodeType,<br>    <span class="hljs-keyword">pub</span> nlink: <span class="hljs-type">u32</span>,<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>size</code>：当前占据的块大小，即文件或目录所占用的磁盘块数。</li><li><code>direct...</code>：直接索引和三级间接索引，用于管理文件或目录的数据块。直接索引可以直接指向数据块，而间接索引则通过索引块来指向数据块。</li><li><code>type_</code>：索引节点类型，分为文件和目录两种类型。</li><li><code>nlink</code>：硬链接数量，即指向该索引节点的硬链接的数量。</li></ul><p><strong>DiskInode</strong>是磁盘上文件（File or Directory）存储的基本形式。通过直接+间接索引的形式管理文件数据。在块获取，空间管理方面根据索引实现。有如下重要方法：</p><ul><li><code>is_file</code> 和 <code>is_dir</code>：类型判断</li><li><code>increase_size</code>和<code>build_tree</code>：DiskInode空间增长和辅助函数。主要是多级索引的递归分配</li><li><code>clear_size</code>和<code>collect_tree_blocks</code>：释放DiskInode的方法和对应的多级索引递归释放</li><li><code>read_at</code>和<code>write_at</code>和<code>get_block_id</code>：读写方法和多级索引获取块ID方法</li></ul><h4 id="DitEntry（DEntry）"><a href="#DitEntry（DEntry）" class="headerlink" title="DitEntry（DEntry）"></a>DitEntry（DEntry）</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DirEntry</span> &#123;<br>    name: [<span class="hljs-type">u8</span>; NAME_LENGTH_LIMIT + <span class="hljs-number">1</span>],<br>    inode_number: <span class="hljs-type">u32</span>,<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>name</code>：Inode Name，即文件或目录的名称。</li><li><code>inode_number</code>：inode 唯一标识，用于唯一标识一个索引节点。</li></ul><p>DirEntry 是 Inode 在 DiskInode 中存储的基本单位。固定为 32B 便于管理。实现了简单的取值方法。主要职能是从 inode block 指向 data block。通过目录项，可以将目录和文件关联起来，实现文件系统的目录结构。</p><h4 id="EFS管理器"><a href="#EFS管理器" class="headerlink" title="EFS管理器"></a>EFS管理器</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">EasyFileSystem</span> &#123;<br>    <span class="hljs-keyword">pub</span> block_device: Arc&lt;<span class="hljs-keyword">dyn</span> BlockDevice&gt;,<br>    <span class="hljs-keyword">pub</span> inode_bitmap: Bitmap,<br>    <span class="hljs-keyword">pub</span> data_bitmap: Bitmap,<br>    inode_area_start_block: <span class="hljs-type">u32</span>,<br>    data_area_start_block: <span class="hljs-type">u32</span>,<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>block_device</code>：管理块的块设备，用于读写磁盘块。</li><li><code>inode_bitmap</code>：管理 inode 分配的 bitmap，用于记录 inode 的使用情况。</li><li><code>data_bitmap</code>：管理数据块分配的 bitmap，用于记录数据块的使用情况。</li><li><code>inode_area_start_block</code>：inode 区域的起始块编号。</li><li><code>data_area_start_block</code>：数据区域的起始块编号。</li></ul><p>EFS 作为整体的文件系统，对接的是磁盘管理和 VFS，为他们提供接口。实现方法：</p><ul><li><code>create</code>：在块设备上创建 EFS，初始化文件系统的超级块、位图和索引节点等。</li><li><code>open</code>：打开块设备，读取文件系统的超级块和位图等信息，验证文件系统的完整性。</li><li><code>root_inode</code>：获取根节点，返回文件系统的根索引节点。</li><li><code>alloc_data</code>和<code>dealloc_data</code>：对接 bitmap 的接口，用于分配和释放数据块。</li></ul><h4 id="easy-fs-fuse"><a href="#easy-fs-fuse" class="headerlink" title="easy-fs-fuse"></a>easy-fs-fuse</h4><p>作用是能把 user&#x2F;src&#x2F;bin&#x2F; 内的所有程序二进制格式打包，加载到预先准备好的 fs.img 中。这样就不需要一个个链接进去了。<code>easy-fs-fuse</code> 是一个用户空间的文件系统，它可以将 user&#x2F;src&#x2F;bin&#x2F; 目录下的所有程序二进制格式打包，并加载到预先准备好的 fs.img 中。这样，在启动 Qemu 时，操作系统可以直接从 fs.img 中读取这些程序，并加载到内存中执行。</p><h3 id="VFS"><a href="#VFS" class="headerlink" title="VFS"></a>VFS</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>连接 EFS 和 OS 内核的抽象层，为他们提供接口，并致力于实现透明化。VFS是一个虚拟文件系统层，它提供了一个统一的接口，使得操作系统内核可以通过相同的方式访问不同类型的文件系统。在 PotatOS 中，VFS 层将 EasyFS 和操作系统内核连接起来，为内核提供了统一的文件访问接口，使得内核可以方便地操作 EasyFS 文件系统。</p><h4 id="Inode"><a href="#Inode" class="headerlink" title="Inode"></a>Inode</h4><p>VFS层主要就是为操作Inode提供接口</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Inode</span> &#123;<br>    name: <span class="hljs-type">String</span>,<br>    block_id: <span class="hljs-type">usize</span>,<br>    block_offset: <span class="hljs-type">usize</span>,<br>    fs: Arc&lt;Mutex&lt;EasyFileSystem&gt;&gt;,<br>    block_device: Arc&lt;<span class="hljs-keyword">dyn</span> BlockDevice&gt;,<br>    inode_id: <span class="hljs-type">u32</span>,<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>name</code>：文件名，即文件或目录的名称。</li><li><code>block_id</code>，<code>block_offset</code>：Inode 在哪个块，块内偏移。可用于定位，通过块编号和块内偏移，可以准确地找到 Inode 在磁盘上的位置。</li><li><code>fs</code>，<code>block_device</code>：当前文件系统和块设备，用于访问文件系统和磁盘块。</li><li><code>inode_id</code>：inode 标识，用于唯一标识一个索引节点。</li></ul><p>Inode 部分为 OS 实现了操作块的接口。可以简单把 Inode 看作文件 &#x2F; 目录。</p><ul><li><code>read_disk_inode</code>和<code>modify_disk_inode</code>：操作 DiskInode，用于读取和修改磁盘上的索引节点信息。</li><li><code>increase_size</code>：一些操作 DiskInode 的接口，用于扩展文件或目录的空间。</li><li><code>create_file</code>和<code>create_dir</code>：创建文件 &#x2F; 目录，用于在文件系统中创建新的文件或目录。</li><li><code>linkat</code>和<code>unlinkat</code>：进行硬链接和作为删除辅助函数，用于创建和删除硬链接。</li><li>一些访问结构的函数，用于获取 Inode 的相关信息。</li></ul><h3 id="File-Trait-File-System"><a href="#File-Trait-File-System" class="headerlink" title="File Trait &amp; File System"></a>File Trait &amp; File System</h3><h4 id="File"><a href="#File" class="headerlink" title="File"></a>File</h4><ul><li><code>write</code>和<code>read</code>：读写文件</li><li><code>stat</code>：文件状态，包括设备号、inode_id、文件类型、硬连接数和padding</li></ul><h4 id="File-System"><a href="#File-System" class="headerlink" title="File System"></a>File System</h4><p>系统调用：</p><ul><li><p><code>sys_write</code>，<code>sys_read</code>，<code>sys_open</code>，<code>sys_close</code>：读写，打开关闭文件</p></li><li><p><code>sys_getcwd</code>，<code>sys_fstat</code>：获取current work directory，获取fstat</p></li><li><p><code>sys_mkdir</code>，<code>sys_remove</code>，<code>remove_dir</code>：目录创建和删除的方法以及辅助函数</p></li></ul><h2 id="IO设备管理"><a href="#IO设备管理" class="headerlink" title="IO设备管理"></a>IO设备管理</h2><p>一个设备需要设备驱动进行管理。而一个设备驱动需要以下的功能：</p><ol><li><strong>设备的扫描 &#x2F; 发现</strong>：检测系统中存在的设备，并识别其类型和特性。</li><li><strong>设备初始化</strong>：对设备进行初始化，配置设备的寄存器和参数，使其处于可用状态。</li><li><strong>准备发送给设备的命令</strong>：根据用户的请求，生成相应的命令，并准备发送给设备。</li><li><strong>通知设备</strong>：将准备好的命令发送给设备，触发设备的操作。</li><li><strong>接受设备通知</strong>：接收设备的响应和通知，处理设备的中断和状态变化。</li><li><strong>卸载设备的同时回收设备资源</strong>：当设备不再使用时，卸载设备驱动，并回收设备所占用的资源。</li></ol><p>这里主要实现了两种设备：</p><ul><li><strong>真实的物理设备</strong>：如<code>URAT</code>，用于实现字符输入和输出。</li><li><strong>虚拟设备</strong>：如各种<code>Virtio</code>设备，用于模拟硬件设备的功能，提高系统的可移植性和兼容性。</li></ul><p><strong>qemu特化</strong></p><p>本项目在 qemu 模拟器上运行，因此要基于 qemu 进行设备管理的特化。</p><p>在 qemu 里，IO 设备的交互以中断为主，轮询为辅。通过<code>PLIC 平台级中断控制器</code>进行。</p><p><strong>确定设备内存映射</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">const</span> MMIO: &amp;[(<span class="hljs-type">usize</span>, <span class="hljs-type">usize</span>)] = &amp;[<br>    (<span class="hljs-number">0x0010_0000</span>, <span class="hljs-number">0x00_2000</span>), <span class="hljs-comment">// VIRT_TEST/RTC  in virt machine</span><br>    (<span class="hljs-number">0x2000000</span>, <span class="hljs-number">0x10000</span>),<br>    (<span class="hljs-number">0xc000000</span>, <span class="hljs-number">0x210000</span>), <span class="hljs-comment">// VIRT_PLIC in virt machine</span><br>    (<span class="hljs-number">0x10000000</span>, <span class="hljs-number">0x9000</span>),  <span class="hljs-comment">// VIRT_UART0 with GPU  in virt machine</span><br>];<br></code></pre></td></tr></table></figure><p><code>MMIO</code>确定了各个设备在qemu里的地址。通过这些地址操作系统可以直接读写设备寄存器进行交互</p><p><strong>设备初始化</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">device_init</span>() &#123;<br>    <span class="hljs-keyword">use</span> riscv::register::sie;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">plic</span> = <span class="hljs-keyword">unsafe</span> &#123; PLIC::<span class="hljs-title function_ invoke__">new</span>(VIRT_PLIC) &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">hart_id</span>: <span class="hljs-type">usize</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">supervisor</span> = IntrTargetPriority::Supervisor;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">machine</span> = IntrTargetPriority::Machine;<br>    plic.<span class="hljs-title function_ invoke__">set_threshold</span>(hart_id, supervisor, <span class="hljs-number">0</span>);<br>    plic.<span class="hljs-title function_ invoke__">set_threshold</span>(hart_id, machine, <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//irq nums: 5 keyboard, 6 mouse, 8 block, 10 uart</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">intr_src_id</span> <span class="hljs-keyword">in</span> [<span class="hljs-number">5usize</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>] &#123;<br>        plic.<span class="hljs-title function_ invoke__">enable</span>(hart_id, supervisor, intr_src_id);<br>        plic.<span class="hljs-title function_ invoke__">set_priority</span>(intr_src_id, <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        sie::<span class="hljs-title function_ invoke__">set_sext</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>设备初始化，也是中断初始化，给每个设备启动中断功能。当中断发生时可以调用对应设备的中断响应函数。在设备初始化过程中，会对 PLIC（Platform-Level Interrupt Controller）进行配置，设置中断阈值和优先级，并使能相应的中断源。同时，会开启外部中断使能位，允许系统接收外部设备的中断请求。</p><h4 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">irq_handler</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">plic</span> = <span class="hljs-keyword">unsafe</span> &#123; PLIC::<span class="hljs-title function_ invoke__">new</span>(VIRT_PLIC) &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">intr_src_id</span> = plic.<span class="hljs-title function_ invoke__">claim</span>(<span class="hljs-number">0</span>, IntrTargetPriority::Supervisor);<br>    <span class="hljs-keyword">match</span> intr_src_id &#123;<br>        <span class="hljs-number">5</span> =&gt; KEYBOARD_DEVICE.<span class="hljs-title function_ invoke__">handle_irq</span>(),<br>        <span class="hljs-number">6</span> =&gt; MOUSE_DEVICE.<span class="hljs-title function_ invoke__">handle_irq</span>(),<br>        <span class="hljs-number">8</span> =&gt; BLOCK_DEVICE.<span class="hljs-title function_ invoke__">handle_irq</span>(),<br>        <span class="hljs-number">10</span> =&gt; UART.<span class="hljs-title function_ invoke__">handle_irq</span>(),<br>        _ =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;unsupported IRQ &#123;&#125;&quot;</span>, intr_src_id),<br>    &#125;<br>    plic.<span class="hljs-title function_ invoke__">complete</span>(<span class="hljs-number">0</span>, IntrTargetPriority::Supervisor, intr_src_id);<br>&#125;<br></code></pre></td></tr></table></figure><p>当发生中断时，操作系统会调用 <code>irq_handler</code> 函数进行处理。该函数会从 PLIC 中获取中断源的编号，并根据编号调用相应设备的中断处理函数。处理完中断后，会通知 PLIC 中断处理完成。</p><h4 id="trap-响应"><a href="#trap-响应" class="headerlink" title="trap 响应"></a>trap 响应</h4><p>写入<code>scause</code>为外部中断，由qemu中断处理</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// trap/mod.rs</span><br><span class="hljs-comment">// ...</span><br>Trap::<span class="hljs-title function_ invoke__">Interrupt</span>(Interrupt::SupervisorExternal) =&gt; &#123;<br>    crate::board::<span class="hljs-title function_ invoke__">irq_handler</span>();<br>&#125;<br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>当发生超级用户外部中断时，操作系统会调用 <code>irq_handler</code> 函数进行处理。这样，操作系统可以及时响应外部设备的中断请求，处理设备的输入和输出。</p><h3 id="串口驱动程序UART"><a href="#串口驱动程序UART" class="headerlink" title="串口驱动程序UART"></a>串口驱动程序UART</h3><p><strong>目的</strong></p><p>把字符输入到操作系统内核里。UART（Universal Asynchronous Receiver&#x2F;Transmitter）是一种通用的异步收发传输器，用于实现字符的输入和输出。在 PotatOS 中，UART 驱动程序负责将用户输入的字符传输到操作系统内核，并将内核输出的字符发送到终端设备。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><strong>ns16550a</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">NS16550aRaw</span> &#123;<br>    base_addr: <span class="hljs-type">usize</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">NS16550aRaw</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_end</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">mut</span> ReadWithoutDLAB &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123; &amp;<span class="hljs-keyword">mut</span> *(<span class="hljs-keyword">self</span>.base_addr <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> ReadWithoutDLAB) &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write_end</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">mut</span> WriteWithoutDLAB &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123; &amp;<span class="hljs-keyword">mut</span> *(<span class="hljs-keyword">self</span>.base_addr <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> WriteWithoutDLAB) &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(base_addr: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">Self</span> &#123; base_addr &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">init</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">read_end</span> = <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">read_end</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">mcr</span> = MCR::<span class="hljs-title function_ invoke__">empty</span>();<br>        mcr |= MCR::DATA_TERMINAL_READY;<br>        mcr |= MCR::REQUEST_TO_SEND;<br>        mcr |= MCR::AUX_OUTPUT2;<br>        read_end.mcr.<span class="hljs-title function_ invoke__">write</span>(mcr);<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">ier</span> = IER::RX_AVAILABLE;<br>        read_end.ier.<span class="hljs-title function_ invoke__">write</span>(ier);<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">read</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u8</span>&gt; &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">read_end</span> = <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">read_end</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">lsr</span> = read_end.lsr.<span class="hljs-title function_ invoke__">read</span>();<br>        <span class="hljs-keyword">if</span> lsr.<span class="hljs-title function_ invoke__">contains</span>(LSR::DATA_AVAILABLE) &#123;<br>            <span class="hljs-title function_ invoke__">Some</span>(read_end.rbr.<span class="hljs-title function_ invoke__">read</span>())<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-literal">None</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, ch: <span class="hljs-type">u8</span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">write_end</span> = <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">write_end</span>();<br>        <span class="hljs-keyword">loop</span> &#123;<br>            <span class="hljs-keyword">if</span> write_end.lsr.<span class="hljs-title function_ invoke__">read</span>().<span class="hljs-title function_ invoke__">contains</span>(LSR::THR_EMPTY) &#123;<br>                write_end.thr.<span class="hljs-title function_ invoke__">write</span>(ch);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>MMIO</code>进行通信，读写。内部是一堆寄存器。<code>NS16550aRaw</code> 是一个原始的 UART 设备结构体，它通过内存映射输入输出（MMIO）的方式与 UART 设备进行通信。在初始化过程中，会配置 UART 设备的寄存器，使能接收中断，并设置相应的控制位。<code>read</code> 方法用于从 UART 设备读取一个字符，<code>write</code> 方法用于向 UART 设备写入一个字符。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ReadWithoutDLAB</span> &#123;<br>    <span class="hljs-comment">/// receiver buffer register</span><br>    <span class="hljs-keyword">pub</span> rbr: ReadOnly&lt;<span class="hljs-type">u8</span>&gt;,<br>    <span class="hljs-comment">/// interrupt enable register</span><br>    <span class="hljs-keyword">pub</span> ier: Volatile&lt;IER&gt;,<br>    <span class="hljs-comment">/// interrupt identification register</span><br>    <span class="hljs-keyword">pub</span> iir: ReadOnly&lt;<span class="hljs-type">u8</span>&gt;,<br>    <span class="hljs-comment">/// line control register</span><br>    <span class="hljs-keyword">pub</span> lcr: Volatile&lt;<span class="hljs-type">u8</span>&gt;,<br>    <span class="hljs-comment">/// model control register</span><br>    <span class="hljs-keyword">pub</span> mcr: Volatile&lt;MCR&gt;,<br>    <span class="hljs-comment">/// line status register</span><br>    <span class="hljs-keyword">pub</span> lsr: ReadOnly&lt;LSR&gt;,<br>    <span class="hljs-comment">/// ignore MSR</span><br>    _padding1: ReadOnly&lt;<span class="hljs-type">u8</span>&gt;,<br>    <span class="hljs-comment">/// ignore SCR</span><br>    _padding2: ReadOnly&lt;<span class="hljs-type">u8</span>&gt;,<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ReadWithoutDLAB</code> 结构体定义了 UART 设备的寄存器布局，包括接收缓冲区寄存器、中断使能寄存器、中断标识寄存器等。通过访问这些寄存器，可以实现对 UART 设备的控制和数据传输。</p><h4 id="中断处理-1"><a href="#中断处理-1" class="headerlink" title="中断处理"></a>中断处理</h4><p>设备包装成<code>u8字节串</code>与内核进行中断交互</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">NS16550a</span>&lt;<span class="hljs-keyword">const</span> BASE_ADDR: <span class="hljs-type">usize</span>&gt; &#123;<br>    inner: UPIntrFreeCell&lt;NS16550aInner&gt;,<br>    condvar: Condvar,<br>&#125;<br></code></pre></td></tr></table></figure><p>通过信号量<code>condvar</code>实现内核部分的信号驱动 IO。当 UART 设备接收到字符时，会触发中断，中断处理函数会将接收到的字符存储到缓冲区中，并通过信号量通知内核有新的字符可用。内核可以通过等待信号量来获取新的字符。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">handle_irq</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">count</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">self</span>.inner.<span class="hljs-title function_ invoke__">exclusive_session</span>(|inner| &#123;<br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(ch) = inner.ns16550a.<span class="hljs-title function_ invoke__">read</span>() &#123;<br>            count += <span class="hljs-number">1</span>;<br>            inner.read_buffer.<span class="hljs-title function_ invoke__">push_back</span>(ch);<br>        &#125;<br>    &#125;);<br>    <span class="hljs-keyword">if</span> count &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">self</span>.condvar.<span class="hljs-title function_ invoke__">signal</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在中断处理函数中，会不断从 UART 设备读取字符，并将其存储到缓冲区中。如果读取到了字符，则通过信号量通知内核。这样，内核可以在有新的字符可用时被唤醒，提高了系统的响应性能。</p><h4 id="内核通信"><a href="#内核通信" class="headerlink" title="内核通信"></a>内核通信</h4><p>UART作为输入设备设立成<code>stdin</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// stdio.rs</span><br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">File</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Stdin</span> &#123;<br><span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">read</span>(&amp;<span class="hljs-keyword">self</span>, <span class="hljs-keyword">mut</span> user_buf: UserBuffer) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>        <span class="hljs-built_in">assert_eq!</span>(user_buf.<span class="hljs-title function_ invoke__">len</span>(), <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//println!(&quot;before UART.read() in Stdin::read()&quot;);</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">ch</span> = UART.<span class="hljs-title function_ invoke__">read</span>();<br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            user_buf.buffers[<span class="hljs-number">0</span>].<span class="hljs-title function_ invoke__">as_mut_ptr</span>().<span class="hljs-title function_ invoke__">write_volatile</span>(ch);<br>        &#125;<br>        <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在进程创建中自动设置<code>stdin</code>，<code>stdout</code>，<code>stderr</code>。UART 设备作为标准输入设备（<code>stdin</code>），用户程序可以通过调用 <code>Stdin</code> 的 <code>read</code> 方法从 UART 设备读取字符。在进程创建时，会自动将 <code>stdin</code>、<code>stdout</code> 和 <code>stderr</code> 分别设置为 UART 设备，方便用户程序进行输入输出操作。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust">fd_table: <span class="hljs-built_in">vec!</span>[<br>    <span class="hljs-comment">// 0 -&gt; stdin</span><br>    <span class="hljs-title function_ invoke__">Some</span>(Arc::<span class="hljs-title function_ invoke__">new</span>(Stdin)),<br>    <span class="hljs-comment">// 1 -&gt; stdout</span><br>    <span class="hljs-title function_ invoke__">Some</span>(Arc::<span class="hljs-title function_ invoke__">new</span>(Stdout)),<br>    <span class="hljs-comment">// 2 -&gt; stderr</span><br>    <span class="hljs-title function_ invoke__">Some</span>(Arc::<span class="hljs-title function_ invoke__">new</span>(Stdout)),<br>],<br></code></pre></td></tr></table></figure><p>此处错误输出自动导向终端</p><h3 id="Virtio-Device"><a href="#Virtio-Device" class="headerlink" title="Virtio Device"></a>Virtio Device</h3><p>作为一个设备接口，允许虚拟机上运行的操作系统<strong>通过访问virtio设备使用主机设备</strong>。这里主要是利用它简单地实现虚拟设备。</p><h3 id="Virtio-Block-Device"><a href="#Virtio-Block-Device" class="headerlink" title="Virtio Block Device"></a>Virtio Block Device</h3><p>我们希望通过操作系统内核对虚拟块设备进行简单的读写。</p><h4 id="block-dev-trait"><a href="#block-dev-trait" class="headerlink" title="block-dev trait"></a>block-dev trait</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">BlockDevice</span>: <span class="hljs-built_in">Send</span> + <span class="hljs-built_in">Sync</span> + Any &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_block</span>(&amp;<span class="hljs-keyword">self</span>, block_id: <span class="hljs-type">usize</span>, buf: &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">u8</span>]);<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write_block</span>(&amp;<span class="hljs-keyword">self</span>, block_id: <span class="hljs-type">usize</span>, buf: &amp;[<span class="hljs-type">u8</span>]);<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">handle_irq</span>(&amp;<span class="hljs-keyword">self</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>块设备需要实现的<code>trait</code>，包括简单的读写和中断处理。在<code>文件系统</code>章节有提及。</p><h4 id="virtio-block"><a href="#virtio-block" class="headerlink" title="virtio-block"></a>virtio-block</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">VirtIOBlk</span>&lt;<span class="hljs-symbol">&#x27;a</span>, H: Hal&gt; &#123;<br>    header: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-keyword">mut</span> VirtIOHeader,<br>    queue: VirtQueue&lt;<span class="hljs-symbol">&#x27;a</span>, H&gt;,<br>    capacity: <span class="hljs-type">usize</span>,<br>&#125;<br><br><span class="hljs-comment">// drivers/block/virtio_blk.rs</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">VirtIOBlock</span> &#123;<br>    virtio_blk: UPIntrFreeCell&lt;VirtIOBlk&lt;<span class="hljs-symbol">&#x27;static</span>, VirtioHal&gt;&gt;,<br>    condvars: BTreeMap&lt;<span class="hljs-type">u16</span>, Condvar&gt;,<br>&#125;<br></code></pre></td></tr></table></figure><p>包含了虚拟块设备的基本结构，包括virtio-driver和多通道通信。</p><p><code>condvars</code>用于实现IO读写。事实上，一个<code>condvar</code>对应一个<code>virtio-queue</code>。virtio-queue是虚拟设备中通过<strong>中断驱动的IO队列，支持轮询</strong>。通过virtio-queue可以实现设备和驱动程序的各种数据传输工作。</p><h4 id="操作系统对接块设备初始化"><a href="#操作系统对接块设备初始化" class="headerlink" title="操作系统对接块设备初始化"></a>操作系统对接块设备初始化</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">VirtIOBlock</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">virtio_blk</span> = <span class="hljs-keyword">unsafe</span> &#123;<br>            UPIntrFreeCell::<span class="hljs-title function_ invoke__">new</span>(<br>                VirtIOBlk::&lt;VirtioHal&gt;::<span class="hljs-title function_ invoke__">new</span>(&amp;<span class="hljs-keyword">mut</span> *(VIRTIO0 <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> VirtIOHeader)).<span class="hljs-title function_ invoke__">unwrap</span>(),<br>            )<br>        &#125;;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">condvars</span> = BTreeMap::<span class="hljs-title function_ invoke__">new</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">channels</span> = virtio_blk.<span class="hljs-title function_ invoke__">exclusive_access</span>(<span class="hljs-built_in">file!</span>(), <span class="hljs-built_in">line!</span>()).<span class="hljs-title function_ invoke__">virt_queue_size</span>();<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..channels &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">condvar</span> = Condvar::<span class="hljs-title function_ invoke__">new</span>();<br>            condvars.<span class="hljs-title function_ invoke__">insert</span>(i, condvar);<br>        &#125;<br>        <span class="hljs-keyword">Self</span> &#123;<br>            virtio_blk,<br>            condvars,<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>初始化<code>virtio-block</code>和<code>channels</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// qemu.rs</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">BlockDeviceImpl</span> = crate::drivers::block::VirtIOBlock;<br><br><span class="hljs-comment">// drivers/block/mod.rs</span><br>lazy_static! &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">ref</span> BLOCK_DEVICE: Arc&lt;<span class="hljs-keyword">dyn</span> BlockDevice&gt; = Arc::<span class="hljs-title function_ invoke__">new</span>(BlockDeviceImpl::<span class="hljs-title function_ invoke__">new</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>全局初始化块设备</p><h4 id="中断处理-2"><a href="#中断处理-2" class="headerlink" title="中断处理"></a>中断处理</h4><p>同上，通过中断进行数据传输。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">handle_irq</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>    <span class="hljs-keyword">self</span>.virtio_blk.<span class="hljs-title function_ invoke__">exclusive_session</span>(|blk| &#123;<br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Ok</span>(token) = blk.<span class="hljs-title function_ invoke__">pop_used</span>() &#123;<br>            <span class="hljs-keyword">self</span>.condvars.<span class="hljs-title function_ invoke__">get</span>(&amp;token).<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">signal</span>();<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>从virtio-queue中取出已使用过的部分进行数据传输</p><h3 id="Virtio-GPU-Device"><a href="#Virtio-GPU-Device" class="headerlink" title="Virtio GPU Device"></a>Virtio GPU Device</h3><p>主要目的是为了<strong>进程调度的图形化</strong>而使用qemu虚拟现实设备。主要的功能是对显示设备内存进行数据读写。通过设置<code>显示屏尺寸</code>，<code>像素点位置</code>和<code>像素点颜色</code>可以实现基本的图形展示。像素点的放置由<code>cursor</code>辅助实现。</p><p><strong>简单的动画实现</strong></p><p>简单地考虑就是：首先程序绘制当前帧，然后屏幕刷新帧。</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">VirtIOGpu</span>&lt;<span class="hljs-symbol">&#x27;a</span>, H: Hal&gt; &#123;<br>    header: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-keyword">mut</span> VirtIOHeader,<br>    rect: Rect,<br>    <span class="hljs-comment">/// DMA area of frame buffer.</span><br>    frame_buffer_dma: <span class="hljs-type">Option</span>&lt;DMA&lt;H&gt;&gt;,<br>    <span class="hljs-comment">/// DMA area of cursor image buffer.</span><br>    cursor_buffer_dma: <span class="hljs-type">Option</span>&lt;DMA&lt;H&gt;&gt;,<br>    <span class="hljs-comment">/// Queue for sending control commands.</span><br>    control_queue: VirtQueue&lt;<span class="hljs-symbol">&#x27;a</span>, H&gt;,<br>    <span class="hljs-comment">/// Queue for sending cursor commands.</span><br>    cursor_queue: VirtQueue&lt;<span class="hljs-symbol">&#x27;a</span>, H&gt;,<br>    <span class="hljs-comment">/// Queue buffer DMA</span><br>    queue_buf_dma: DMA&lt;H&gt;,<br>    <span class="hljs-comment">/// Send buffer for queue.</span><br>    queue_buf_send: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> [<span class="hljs-type">u8</span>],<br>    <span class="hljs-comment">/// Recv buffer for queue.</span><br>    queue_buf_recv: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> [<span class="hljs-type">u8</span>],<br>&#125;<br></code></pre></td></tr></table></figure><p>为了提高系统执行效率，<code>像素内存</code>和<code>光标显示内存</code>由<strong>DMA</strong>管理并进行数据传输。</p><p>这里的DMA使用前文<code>内存管理</code>提到的函数方法直接访问物理&#x2F;虚拟内存。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DMA</span>&lt;H: Hal&gt; &#123;<br>    paddr: <span class="hljs-type">usize</span>,<br>    pages: <span class="hljs-type">usize</span>,<br>    _phantom: PhantomData&lt;H&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;H: Hal&gt; DMA&lt;H&gt; &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(pages: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-keyword">Self</span>&gt; &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">paddr</span> = H::<span class="hljs-title function_ invoke__">dma_alloc</span>(pages);<br>        <span class="hljs-keyword">if</span> paddr == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(Error::DmaError);<br>        &#125;<br>        <span class="hljs-title function_ invoke__">Ok</span>(DMA &#123;<br>            paddr,<br>            pages,<br>            _phantom: PhantomData::<span class="hljs-title function_ invoke__">default</span>(),<br>        &#125;)<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">paddr</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>        <span class="hljs-keyword">self</span>.paddr<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">vaddr</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>        H::<span class="hljs-title function_ invoke__">phys_to_virt</span>(<span class="hljs-keyword">self</span>.paddr)<br>    &#125;<br><br>    <span class="hljs-comment">/// Returns the physical page frame number.</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">pfn</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>        (<span class="hljs-keyword">self</span>.paddr &gt;&gt; <span class="hljs-number">12</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span><br>    &#125;<br><br>    <span class="hljs-comment">/// Convert to a buffer</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">as_buf</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-keyword">mut</span> [<span class="hljs-type">u8</span>] &#123;<br>        core::slice::<span class="hljs-title function_ invoke__">from_raw_parts_mut</span>(<span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">vaddr</span>() <span class="hljs-keyword">as</span> _, PAGE_SIZE * <span class="hljs-keyword">self</span>.pages <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;H: Hal&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">DMA</span>&lt;H&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">err</span> = H::<span class="hljs-title function_ invoke__">dma_dealloc</span>(<span class="hljs-keyword">self</span>.paddr <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>, <span class="hljs-keyword">self</span>.pages <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>);<br>        <span class="hljs-built_in">assert_eq!</span>(err, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;failed to deallocate DMA&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/// The interface which a particular hardware implementation must implement.</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Hal</span> &#123;<br>    <span class="hljs-comment">/// Allocates the given number of contiguous physical pages of DMA memory for virtio use.</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">dma_alloc</span>(pages: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> PhysAddr;<br>    <span class="hljs-comment">/// Deallocates the given contiguous physical DMA memory pages.</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">dma_dealloc</span>(paddr: PhysAddr, pages: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>;<br>    <span class="hljs-comment">/// Converts a physical address used for virtio to a virtual address which the program can</span><br>    <span class="hljs-comment">/// access.</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">phys_to_virt</span>(paddr: PhysAddr) <span class="hljs-punctuation">-&gt;</span> VirtAddr;<br>    <span class="hljs-comment">/// Converts a virtual address which the program can access to the corresponding physical</span><br>    <span class="hljs-comment">/// address to use for virtio.</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">virt_to_phys</span>(vaddr: VirtAddr) <span class="hljs-punctuation">-&gt;</span> PhysAddr;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>trait Hal</code>直接申请物理页表和物理地址，从而不使用中断直接访问地址空间。这样可以加速系统执行效率</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Hal</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">VirtioHal</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">dma_alloc</span>(pages: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">trakcers</span> = <span class="hljs-title function_ invoke__">frame_alloc_more</span>(pages);<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">ppn_base</span> = trakcers.<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">last</span>().<span class="hljs-title function_ invoke__">unwrap</span>().ppn;<br>        QUEUE_FRAMES<br>            .<span class="hljs-title function_ invoke__">exclusive_access</span>(<span class="hljs-built_in">file!</span>(), <span class="hljs-built_in">line!</span>())<br>            .<span class="hljs-title function_ invoke__">append</span>(&amp;<span class="hljs-keyword">mut</span> trakcers.<span class="hljs-title function_ invoke__">unwrap</span>());<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">pa</span>: PhysAddr = ppn_base.<span class="hljs-title function_ invoke__">into</span>();<br>        pa.<span class="hljs-number">0</span><br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">dma_dealloc</span>(pa: <span class="hljs-type">usize</span>, pages: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">pa</span> = PhysAddr::<span class="hljs-title function_ invoke__">from</span>(pa);<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">ppn_base</span>: PhysPageNum = pa.<span class="hljs-title function_ invoke__">into</span>();<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..pages &#123;<br>            <span class="hljs-title function_ invoke__">frame_dealloc</span>(ppn_base);<br>            ppn_base.<span class="hljs-title function_ invoke__">step</span>();<br>        &#125;<br>        <span class="hljs-number">0</span><br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">phys_to_virt</span>(addr: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>        addr<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">virt_to_phys</span>(vaddr: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>        PageTable::<span class="hljs-title function_ invoke__">from_token</span>(<span class="hljs-title function_ invoke__">kernel_token</span>())<br>            .<span class="hljs-title function_ invoke__">translate_va</span>(VirtAddr::<span class="hljs-title function_ invoke__">from</span>(vaddr))<br>            .<span class="hljs-title function_ invoke__">unwrap</span>()<br>            .<span class="hljs-number">0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="初始化虚拟GPU设备"><a href="#初始化虚拟GPU设备" class="headerlink" title="初始化虚拟GPU设备"></a>初始化虚拟GPU设备</h4><p>这一步就是返回一个初始化后的GPU设备</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(header: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-keyword">mut</span> VirtIOHeader) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-keyword">Self</span>&gt; &#123;<br>        header.<span class="hljs-title function_ invoke__">begin_init</span>(|features| &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">features</span> = Features::<span class="hljs-title function_ invoke__">from_bits_truncate</span>(features);<br>            info!(<span class="hljs-string">&quot;Device features &#123;:?&#125;&quot;</span>, features);<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">supported_features</span> = Features::<span class="hljs-title function_ invoke__">empty</span>();<br>            (features &amp; supported_features).<span class="hljs-title function_ invoke__">bits</span>()<br>        &#125;);<br><br>        <span class="hljs-comment">// read configuration space</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">config</span> = <span class="hljs-keyword">unsafe</span> &#123; &amp;<span class="hljs-keyword">mut</span> *(header.<span class="hljs-title function_ invoke__">config_space</span>() <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> Config) &#125;;<br>        info!(<span class="hljs-string">&quot;Config: &#123;:?&#125;&quot;</span>, config);<br><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">control_queue</span> = VirtQueue::<span class="hljs-title function_ invoke__">new</span>(header, QUEUE_TRANSMIT, <span class="hljs-number">2</span>)?;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">cursor_queue</span> = VirtQueue::<span class="hljs-title function_ invoke__">new</span>(header, QUEUE_CURSOR, <span class="hljs-number">2</span>)?;<br><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">queue_buf_dma</span> = DMA::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">2</span>)?;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">queue_buf_send</span> = <span class="hljs-keyword">unsafe</span> &#123; &amp;<span class="hljs-keyword">mut</span> queue_buf_dma.<span class="hljs-title function_ invoke__">as_buf</span>()[..PAGE_SIZE] &#125;;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">queue_buf_recv</span> = <span class="hljs-keyword">unsafe</span> &#123; &amp;<span class="hljs-keyword">mut</span> queue_buf_dma.<span class="hljs-title function_ invoke__">as_buf</span>()[PAGE_SIZE..] &#125;;<br><br>        header.<span class="hljs-title function_ invoke__">finish_init</span>();<br><br>        <span class="hljs-title function_ invoke__">Ok</span>(VirtIOGpu &#123;<br>            header,<br>            frame_buffer_dma: <span class="hljs-literal">None</span>,<br>            cursor_buffer_dma: <span class="hljs-literal">None</span>,<br>            rect: Rect::<span class="hljs-title function_ invoke__">default</span>(),<br>            control_queue,<br>            cursor_queue,<br>            queue_buf_dma,<br>            queue_buf_send,<br>            queue_buf_recv,<br>        &#125;)<br>    &#125;<br></code></pre></td></tr></table></figure><p>为了能够实现图形化，还需要建立<strong>显示区域</strong>，即<strong>渲染帧</strong>和<strong>刷新帧</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">setup_framebuffer</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;&amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">u8</span>]&gt; &#123;<br>        <span class="hljs-comment">// get display info</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">display_info</span> = <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">get_display_info</span>()?;<br>        info!(<span class="hljs-string">&quot;=&gt; &#123;:?&#125;&quot;</span>, display_info);<br>        <span class="hljs-keyword">self</span>.rect = display_info.rect;<br><br>        <span class="hljs-comment">// create resource 2d</span><br>        <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">resource_create_2d</span>(<br>            RESOURCE_ID_FB,<br>            display_info.rect.width,<br>            display_info.rect.height,<br>        )?;<br><br>        <span class="hljs-comment">// alloc continuous pages for the frame buffer</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">size</span> = display_info.rect.width * display_info.rect.height * <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">frame_buffer_dma</span> = DMA::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">pages</span>(size <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>))?;<br><br>        <span class="hljs-comment">// resource_attach_backing</span><br>        <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">resource_attach_backing</span>(RESOURCE_ID_FB, frame_buffer_dma.<span class="hljs-title function_ invoke__">paddr</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">u64</span>, size)?;<br><br>        <span class="hljs-comment">// map frame buffer to screen</span><br>        <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">set_scanout</span>(display_info.rect, SCANOUT_ID, RESOURCE_ID_FB)?;<br><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">buf</span> = <span class="hljs-keyword">unsafe</span> &#123; frame_buffer_dma.<span class="hljs-title function_ invoke__">as_buf</span>() &#125;;<br>        <span class="hljs-keyword">self</span>.frame_buffer_dma = <span class="hljs-title function_ invoke__">Some</span>(frame_buffer_dma);<br>        <span class="hljs-title function_ invoke__">Ok</span>(buf)<br>    &#125;<br></code></pre></td></tr></table></figure><p>这一步设置了<code>显示设置</code>，即设备尺寸和分辨率。一个像素大小<code>4字节</code>，然后链接帧和屏幕。</p><h4 id="虚拟GPU设备IO操作"><a href="#虚拟GPU设备IO操作" class="headerlink" title="虚拟GPU设备IO操作"></a>虚拟GPU设备IO操作</h4><p>如上所言，GPU设备仅需要两步操作：</p><ol><li>渲染帧：把像素数据刷入显存内</li><li>刷新帧：把新帧刷到屏幕上</li></ol><h4 id="虚拟GPU驱动"><a href="#虚拟GPU驱动" class="headerlink" title="虚拟GPU驱动"></a>虚拟GPU驱动</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">GpuDevice</span>: <span class="hljs-built_in">Send</span> + <span class="hljs-built_in">Sync</span> + Any &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_framebuffer</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">u8</span>];<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">flush</span>(&amp;<span class="hljs-keyword">self</span>);<br>&#125;<br><br>lazy_static::lazy_static!(<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">ref</span> GPU_DEVICE: Arc&lt;<span class="hljs-keyword">dyn</span> GpuDevice&gt; = Arc::<span class="hljs-title function_ invoke__">new</span>(VirtIOGpuWrapper::<span class="hljs-title function_ invoke__">new</span>());<br>);<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">VirtIOGpuWrapper</span> &#123;<br>    gpu: UPIntrFreeCell&lt;VirtIOGpu&lt;<span class="hljs-symbol">&#x27;static</span>, VirtioHal&gt;&gt;,<br>    fb: &amp;<span class="hljs-symbol">&#x27;static</span> [<span class="hljs-type">u8</span>],<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">GpuDevice</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">VirtIOGpuWrapper</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">flush</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">self</span>.gpu.<span class="hljs-title function_ invoke__">exclusive_access</span>(<span class="hljs-built_in">file!</span>(), <span class="hljs-built_in">line!</span>()).<span class="hljs-title function_ invoke__">flush</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_framebuffer</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">u8</span>] &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">ptr</span> = <span class="hljs-keyword">self</span>.fb.<span class="hljs-title function_ invoke__">as_ptr</span>() <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> _ <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-type">u8</span>;<br>            core::slice::<span class="hljs-title function_ invoke__">from_raw_parts_mut</span>(ptr, <span class="hljs-keyword">self</span>.fb.<span class="hljs-title function_ invoke__">len</span>())<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虚拟GPU设备采用<code>DMA</code>，因此与操作系统的交互不需要进行地址变换，直接进行字节读写即可。</p><p>现在<strong>内核态</strong>可以直接使用虚拟GPU设备。但是想要在用户态使用(设计应用)还需要系统调用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sys_framebuffer</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">isize</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">fb</span> = GPU_DEVICE.<span class="hljs-title function_ invoke__">get_framebuffer</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = fb.<span class="hljs-title function_ invoke__">len</span>();<br>    <span class="hljs-comment">// println!(&quot;[kernel] FrameBuffer: addr 0x&#123;:X&#125;, len &#123;&#125;&quot;, fb.as_ptr() as usize , len);</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">fb_start_pa</span> = PhysAddr::<span class="hljs-title function_ invoke__">from</span>(fb.<span class="hljs-title function_ invoke__">as_ptr</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>);<br>    <span class="hljs-built_in">assert!</span>(fb_start_pa.<span class="hljs-title function_ invoke__">aligned</span>());<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">fb_start_ppn</span> = fb_start_pa.<span class="hljs-title function_ invoke__">floor</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">fb_start_vpn</span> = VirtAddr::<span class="hljs-title function_ invoke__">from</span>(FB_VADDR).<span class="hljs-title function_ invoke__">floor</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">pn_offset</span> = fb_start_ppn.<span class="hljs-number">0</span> <span class="hljs-keyword">as</span> <span class="hljs-type">isize</span> - fb_start_vpn.<span class="hljs-number">0</span> <span class="hljs-keyword">as</span> <span class="hljs-type">isize</span>;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">current_process</span> = <span class="hljs-title function_ invoke__">current_process</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">inner</span> = current_process.<span class="hljs-title function_ invoke__">inner_exclusive_access</span>(<span class="hljs-built_in">file!</span>(), <span class="hljs-built_in">line!</span>());<br>    inner.memory_set.<span class="hljs-title function_ invoke__">push</span>(<br>        MapArea::<span class="hljs-title function_ invoke__">new</span>(<br>            (FB_VADDR <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>).<span class="hljs-title function_ invoke__">into</span>(),<br>            (FB_VADDR + len <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>).<span class="hljs-title function_ invoke__">into</span>(),<br>            MapType::<span class="hljs-title function_ invoke__">Linear</span>(pn_offset),<br>            MapPermission::R | MapPermission::W | MapPermission::U,<br>        ),<br>        <span class="hljs-literal">None</span>,<br>    );<br>    FB_VADDR <span class="hljs-keyword">as</span> <span class="hljs-type">isize</span><br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sys_framebuffer_flush</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">isize</span> &#123;<br>    GPU_DEVICE.<span class="hljs-title function_ invoke__">flush</span>();<br>    <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这两个系统调用分别对应了两个步骤：<strong>获取帧地址并尝试渲染</strong>和<strong>刷新帧</strong></p><h4 id="移植图形库辅助开发"><a href="#移植图形库辅助开发" class="headerlink" title="移植图形库辅助开发"></a>移植图形库辅助开发</h4><p>图形库<strong>embedded-graphics</strong>为图形化的开发提供很多便利，仅需要实现<code>trait Display</code>即可方便作画</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Display</span> &#123;<br>    <span class="hljs-keyword">pub</span> size: Size,<br>    <span class="hljs-keyword">pub</span> fb: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-keyword">mut</span> [<span class="hljs-type">u8</span>],<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Display</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(size: Size) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">fb_ptr</span> = <span class="hljs-title function_ invoke__">framebuffer</span>() <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-type">u8</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">fb</span> = <span class="hljs-keyword">unsafe</span> &#123; core::slice::<span class="hljs-title function_ invoke__">from_raw_parts_mut</span>(fb_ptr, VIRTGPU_LEN <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>) &#125;;<br>        <span class="hljs-keyword">Self</span> &#123; size, fb &#125;<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">framebuffer</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">u8</span>] &#123;<br>        <span class="hljs-keyword">self</span>.fb<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">paint_on_framebuffer</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, p: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">FnOnce</span>(&amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">u8</span>]) <span class="hljs-punctuation">-&gt;</span> ()) &#123;<br>        <span class="hljs-title function_ invoke__">p</span>(<span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">framebuffer</span>());<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">flush</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-title function_ invoke__">framebuffer_flush</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">OriginDimensions</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Display</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">size</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> Size &#123;<br>        <span class="hljs-keyword">self</span>.size<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">DrawTarget</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Display</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Color</span> = Rgb888;<br><br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Error</span> = core::convert::Infallible;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">draw_iter</span>&lt;I&gt;(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, pixels: I) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), <span class="hljs-keyword">Self</span>::Error&gt;<br>    <span class="hljs-keyword">where</span><br>        I: <span class="hljs-built_in">IntoIterator</span>&lt;Item = embedded_graphics::Pixel&lt;<span class="hljs-keyword">Self</span>::Color&gt;&gt;,<br>    &#123;<br>        pixels.<span class="hljs-title function_ invoke__">into_iter</span>().for_each(|px| &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">idx</span> = (px.<span class="hljs-number">0</span>.y * VIRTGPU_XRES <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span> + px.<span class="hljs-number">0</span>.x) <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span> * <span class="hljs-number">4</span>;<br>            <span class="hljs-keyword">if</span> idx + <span class="hljs-number">2</span> &gt;= <span class="hljs-keyword">self</span>.fb.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">self</span>.fb[idx] = px.<span class="hljs-number">1</span>.<span class="hljs-title function_ invoke__">b</span>();<br>            <span class="hljs-keyword">self</span>.fb[idx + <span class="hljs-number">1</span>] = px.<span class="hljs-number">1</span>.<span class="hljs-title function_ invoke__">g</span>();<br>            <span class="hljs-keyword">self</span>.fb[idx + <span class="hljs-number">2</span>] = px.<span class="hljs-number">1</span>.<span class="hljs-title function_ invoke__">r</span>();<br>        &#125;);<br>        <span class="hljs-title function_ invoke__">Ok</span>(())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，就可以通过该图形库辅助图形化开发。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p><a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/">https://rcore-os.cn/rCore-Tutorial-Book-v3/</a></p></li><li><p><a href="https://github.com/isrc-cas/riscv-isa-manual-cn">https://github.com/isrc-cas/riscv-isa-manual-cn</a></p></li><li><p><a href="https://rustmagazine.github.io/rust_magazine_2021/">https://rustmagazine.github.io/rust_magazine_2021/</a></p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>设计文档</tag>
      
      <tag>课程设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>项目</title>
    <link href="/2025/03/02/%E9%A1%B9%E7%9B%AE/"/>
    <url>/2025/03/02/%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><h2 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h2><p>多副本状态机，解决<strong>强一致性</strong>问题</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><strong>持久状态（Hard State）</strong></p><ul><li>currentTerm：像TS一样确定时间</li><li>votedFor：</li><li>log[]：</li></ul><p><strong>易失性状态（Soft State）on All Server</strong></p><ul><li>commitIndex：集群共识的最新commit index</li><li>lastApplied：每个节点应用于自身的最新index</li></ul><p><em>通常有lastApplied &lt;&#x3D; commitIndex</em></p><p><strong>易失性状态 on Leader</strong></p><p><em>Leader给Follower维护的变量</em></p><ul><li>nextIndex[]：下一个要发送的index</li><li>matchIndex[]：已成功发送的index</li></ul><p><strong>AppendEntries RPC</strong></p><ul><li>term：leader当前RPC任期</li><li>leaderID</li><li>prevLogIndex：确认index和term一致，或者定位分歧点，nextIndex - 1</li><li>prevLogTerm：即follower与leader不一致的第一处</li><li>entries[]</li><li>leaderCommit</li></ul><p>return</p><ul><li>success</li><li>term</li></ul><p><strong>RequestVote RPC</strong></p><ul><li>term</li><li>candidateID</li><li>lastLogIndex</li><li>lastLogTerm</li></ul><p>return</p><ul><li>term</li><li>voteGranted：赢得选票</li></ul><h4 id="时间要求"><a href="#时间要求" class="headerlink" title="时间要求"></a>时间要求</h4><blockquote><p>stTime） &lt;&lt; 选举超时时间（electionTimeout） &lt;&lt; 平均故障间隔时间（MTBF）</p></blockquote><h3 id="Leader-Election-Heartbeats"><a href="#Leader-Election-Heartbeats" class="headerlink" title="Leader Election &amp; Heartbeats"></a>Leader Election &amp; Heartbeats</h3><h4 id="RequestVote"><a href="#RequestVote" class="headerlink" title="RequestVote"></a><strong>RequestVote</strong></h4><p>接收者实现：</p><ol><li>如果<code>term &lt; currentTerm</code>返回 false （老节点）</li><li>如果 votedFor 为空或者为 candidateId，并且候选人的日志至少和自己一样新，那么就投票给他（可投票）</li></ol><p><strong>所有服务器需遵守的规则</strong>：</p><p>所有服务器：</p><ul><li>如果<code>commitIndex &gt; lastApplied</code>，则 lastApplied 递增，并将<code>log[lastApplied]</code>应用到状态机中（状态更新到最新）</li><li>如果接收到的 RPC 请求或响应中，任期号<code>T &gt; currentTerm</code>，则令 <code>currentTerm = T</code>，并切换为跟随者状态（遇到新节点，更新状态）</li></ul><p>跟随者（5.2 节）：</p><ul><li>响应来自候选人和领导人的请求</li><li>如果在超过选举超时时间的情况之前没有收到<strong>当前领导人</strong>（即该领导人的任期需与这个跟随者的当前任期相同）的心跳&#x2F;附加日志，或者是给某个候选人投了票，就自己变成候选人</li></ul><p>候选人（5.2 节）：</p><ul><li>在转变成候选人后就立即开始选举过程<ul><li>自增当前的任期号（currentTerm）</li><li>给自己投票</li><li>重置选举超时计时器</li><li>发送请求投票的 RPC 给其他所有服务器</li></ul></li><li>如果接收到大多数服务器的选票，那么就变成领导人</li><li>如果接收到来自新的领导人的附加日志（AppendEntries）RPC，则转变成跟随者</li><li>如果选举过程超时，则再次发起一轮选举</li></ul><p>领导人：</p><ul><li><p>一旦成为领导人：发送空的附加日志（AppendEntries）RPC（心跳）给其他所有的服务器；在一定的空余时间之后不停的重复发送，以防止跟随者超时（5.2 节）</p></li><li><p>如果接收到来自客户端的请求：附加条目到本地日志中，在条目被应用到状态机后响应客户端（5.3 节）</p></li><li><p>如果对于一个跟随者，最后日志条目的索引值大于等于 nextIndex（</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">lastLogIndex ≥ <span class="hljs-built_in">nextIndex</span><br></code></pre></td></tr></table></figure><p>），则发送从 nextIndex 开始的所有日志条目：</p><ul><li>如果成功：更新相应跟随者的 nextIndex 和 matchIndex</li><li>如果因为日志不一致而失败，则 nextIndex 递减并重试</li></ul></li><li><p>假设存在 N 满足<code>N &gt; commitIndex</code>，使得大多数的 <code>matchIndex[i] ≥ N</code>以及<code>log[N].term == currentTerm</code> 成立，则令 <code>commitIndex = N</code>（5.3 和 5.4 节）</p></li></ul><h4 id="AppendEntries"><a href="#AppendEntries" class="headerlink" title="AppendEntries"></a>AppendEntries</h4><p>接收者的实现：</p><ol><li>返回假 如果领导人的任期小于接收者的当前任期（译者注：这里的接收者是指跟随者或者候选人）（5.1 节）</li><li>返回假 如果接收者日志中没有包含这样一个条目 即该条目的任期在 prevLogIndex 上能和 prevLogTerm 匹配上 （译者注：在接收者日志中 如果能找到一个和 prevLogIndex 以及 prevLogTerm 一样的索引和任期的日志条目 则继续执行下面的步骤 否则返回假）（5.3 节）</li><li>如果一个已经存在的条目和新条目（译者注：即刚刚接收到的日志条目）发生了冲突（因为索引相同，任期不同），那么就删除这个已经存在的条目以及它之后的所有条目 （5.3 节）</li><li>追加日志中尚未存在的任何新条目</li><li>如果领导人的已知已提交的最高日志条目的索引大于接收者的已知已提交最高日志条目的索引（<code>leaderCommit &gt; commitIndex</code>），则把接收者的已知已经提交的最高的日志条目的索引commitIndex 重置为 领导人的已知已经提交的最高的日志条目的索引 leaderCommit 或者是 上一个新条目的索引 取两者的最小值</li></ol><h4 id="ticker"><a href="#ticker" class="headerlink" title="ticker"></a>ticker</h4><p>计时确保选举和心跳顺利进行</p><h4 id="sendHeartbeat"><a href="#sendHeartbeat" class="headerlink" title="sendHeartbeat"></a>sendHeartbeat</h4><p>同步Follower日志，特殊的AppendEntries</p><h3 id="Log日志"><a href="#Log日志" class="headerlink" title="Log日志"></a>Log日志</h3><blockquote><p>Life is Append-Only</p></blockquote><p>如何设置一个协程触发AppendEntries?</p><h4 id="ApplyChannel-ApplyMsg"><a href="#ApplyChannel-ApplyMsg" class="headerlink" title="ApplyChannel &amp; ApplyMsg"></a>ApplyChannel &amp; ApplyMsg</h4><p>实现了<strong>Raft</strong>和<strong>状态机</strong>之间的解耦，负责打包传递复制的日志。</p><p>实际上本程序仅实现了状态机内部的功能，外部的接口和调用还需观察。</p><p>外部通过<strong>applyCh</strong>获得更新的日志，并且检查？</p><p>当commitIndex更新时，需要解开<strong>applyCond</strong>进行及时传递。</p><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><h2 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h2><p>​面试总结：SRE岗位</p><h4 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h4><p>作为一名计算机科学专业的学生，我参与了2024年全国大学生计算机系统能力大赛PolarDB数据库创新设计赛（天池杯），负责数据库性能优化工作。我们的目标是通过多种优化策略，将PolarDB在TPC-H基准测试中的性能提升78.5%。以下是我在项目中的主要贡献和经验总结，以及如何将这些经验应用于SRE岗位。</p><h4 id="项目经验与SRE相关性"><a href="#项目经验与SRE相关性" class="headerlink" title="项目经验与SRE相关性"></a>项目经验与SRE相关性</h4><ol><li><p><strong>系统优化与性能提升</strong></p><ul><li><p><strong>参数优化：</strong> 调整数据库配置参数，如内存使用、并行设置等，确保系统在高负载下稳定运行。这与SRE的核心职责——优化系统性能和可靠性——高度契合。</p></li><li><p><strong>编译优化：</strong> 通过关闭调试模式和采用O3优化，显著提升查询速度。这体现了我对系统底层优化的理解，有助于在SRE岗位中优化生产环境中的系统性能。</p><blockquote><p>编译优化：循环优化，内联，SIMD，数据对齐，缓存读取</p></blockquote></li><li><p><strong>查询优化：</strong> 重写SQL语句，使用CTE替代子查询，减少资源消耗。这展示了我在提高系统效率方面的技能，对SRE中的性能优化和应急响应有直接帮助。</p></li></ul></li><li><p><strong>系统监控与分析</strong></p><ul><li><strong>性能监控：</strong> 使用指标如查询响应时间、系统资源利用率等，监控优化效果。这与SRE中使用监控工具（如Prometheus、Grafana）分析系统状态相似。</li><li><strong>日志分析：</strong> 通过分析日志，识别性能瓶颈和潜在问题。这与SRE中通过日志排查系统故障的经验一致。</li></ul></li><li><p><strong>自动化与工具开发</strong></p><ul><li><strong>脚本编写：</strong> 开发自动化脚本（如<code>tpch_copy.sh</code>和<code>polardb_build.sh</code>），简化数据导入和数据库初始化流程。这体现了我在自动化运维方面的技能，对SRE中的自动化部署和维护至关重要。</li><li><strong>工具集成：</strong> 尝试集成DuckDB与PolarDB，虽然未成功，但积累的经验帮助我理解不同数据库间的兼容性和集成挑战。这对SRE中的工具链整合和优化有参考价值。</li></ul></li><li><p><strong>故障排除与应急响应</strong></p><ul><li><strong>失败尝试分析：</strong> 在尝试内存列存储和DuckDB集成时遇到问题，通过分析失败原因，调整优化策略。这培养了我在面对系统故障时的分析和解决问题的能力，对SRE中的应急响应和故障排除有直接帮助。</li><li><strong>系统回滚：</strong> 在优化过程中，确保能够快速回滚到稳定版本。这体现了我对系统变更的谨慎态度，对SRE中的版本管理和风险控制有借鉴意义。</li></ul></li></ol><h4 id="具体贡献与经验总结"><a href="#具体贡献与经验总结" class="headerlink" title="具体贡献与经验总结"></a>具体贡献与经验总结</h4><ol><li><strong>参数优化</strong><ul><li><strong>贡献：</strong> 调整内存使用、并行设置和日志配置，优化系统资源分配，提升查询性能。</li><li><strong>经验：</strong> 参数调整需要综合考虑系统负载、资源限制和业务需求，避免过度优化导致的不可靠性。</li></ul></li><li><strong>编译优化</strong><ul><li><strong>贡献：</strong> 关闭调试模式，采用O3优化，提升查询速度。</li><li><strong>经验：</strong> 编译优化对系统性能有显著影响，但在生产环境中需要权衡性能和调试能力。</li></ul></li><li><strong>查询优化</strong><ul><li><strong>贡献：</strong> 重写复杂查询，使用CTE和物化视图，减少中间结果集大小，提升查询效率。</li><li><strong>经验：</strong> 了解数据库执行计划和优化器行为是提升查询性能的关键。</li></ul></li><li><strong>内核优化</strong><ul><li><strong>贡献：</strong> 引入列存储和分区表优化，提升数据读取效率。</li><li><strong>经验：</strong> 系统内核优化需要深入了解数据库存储机制和查询执行流程。</li></ul></li><li><strong>失败尝试</strong><ul><li><strong>内存列存储：</strong> 尝试使用内存列存储加速查询，但因数据加载和系统重启问题放弃。</li><li><strong>经验：</strong> 在选择技术方案时，需评估其对系统可靠性和维护成本的影响。</li><li><strong>DuckDB集成：</strong> 尝试将DuckDB与PolarDB集成，但因存储格式和优化器不兼容失败。</li><li><strong>经验：</strong> 集成不同系统时，需充分考虑其底层实现和兼容性问题。</li></ul></li></ol><h4 id="从项目到SRE的技能迁移"><a href="#从项目到SRE的技能迁移" class="headerlink" title="从项目到SRE的技能迁移"></a>从项目到SRE的技能迁移</h4><ol><li><strong>系统优化与性能提升</strong><ul><li><strong>技能迁移：</strong> 在SRE岗位中，优化系统性能以提升可靠性是核心任务。我通过参数和查询优化积累了丰富的经验，能够快速识别和解决生产环境中的性能瓶颈。</li></ul></li><li><strong>自动化运维</strong><ul><li><strong>技能迁移：</strong> 自动化是SRE工作的基石。我开发的自动化脚本培养了我编写高效运维工具的能力，能够快速实现任务自动化，减少人为错误。</li></ul></li><li><strong>监控与分析</strong><ul><li><strong>技能迁移：</strong> 熟练使用监控工具分析系统状态，快速定位问题。我通过性能监控和日志分析积累了丰富的经验，能够有效应对系统故障。</li></ul></li><li><strong>故障排除与应急响应</strong><ul><li><strong>技能迁移：</strong> 在项目中处理失败尝试和系统回滚的经历，培养了我冷静分析和快速解决问题的能力，这对SRE中的应急响应至关重要。</li></ul></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过参与PolarDB数据库优化项目，我积累了丰富的系统优化、监控、自动化运维和故障排除经验，这些能力与SRE的核心职责高度契合。我有信心将这些经验应用到实际工作中，为团队的系统可靠性提升和持续改进做出贡献。</p><h2 id="CMU15445"><a href="#CMU15445" class="headerlink" title="CMU15445"></a>CMU15445</h2><h3 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h3><h4 id="LRU-K"><a href="#LRU-K" class="headerlink" title="LRU-K"></a>LRU-K</h4><p>冷热数据分离，维护一个访问大于等于K和一个小于K的优先队列。</p><p>计数型互斥锁</p><h4 id="Disk-Scheduler"><a href="#Disk-Scheduler" class="headerlink" title="Disk Scheduler"></a>Disk Scheduler</h4><p>简单的队列</p><h4 id="Buffer-Pool-Manager"><a href="#Buffer-Pool-Manager" class="headerlink" title="Buffer Pool Manager"></a>Buffer Pool Manager</h4><ul><li><code>FetchPage(page_id_t page_id)</code>：给定pageid返回物理页。先查看缓存page table，没有则进入磁盘获取，顺便加入缓存。和NewPage很像。</li><li><code>UnpinPage(page_id_t page_id, bool is_dirty)</code>：计数互斥锁，记得设置Evictable</li><li><code>FlushPage(page_id_t page_id)</code>：写入对应pageid的数据</li><li><code>NewPage(page_id_t* page_id)</code>：在缓存池中创建一个新page</li><li><code>DeletePage(page_id_t page_id)</code>：注意上锁，释放page和对应frame</li><li><code>FlushAllPages()</code>：把缓存的page全部刷入磁盘</li></ul><h3 id="Extendible-Hash-Index"><a href="#Extendible-Hash-Index" class="headerlink" title="Extendible Hash Index"></a>Extendible Hash Index</h3><h4 id="R-W-Page-Guards"><a href="#R-W-Page-Guards" class="headerlink" title="R&#x2F;W Page Guards"></a>R&#x2F;W Page Guards</h4><p>RAII</p><h4 id="Extendible-Hash-Table-Pages"><a href="#Extendible-Hash-Table-Pages" class="headerlink" title="Extendible Hash Table Pages"></a>Extendible Hash Table Pages</h4><table><thead><tr><th>Variable Name</th><th>Size</th><th>Description</th></tr></thead><tbody><tr><td><code>max_depth_</code></td><td>4</td><td>The maximum depth the header page could handle</td></tr><tr><td><code>global_depth_</code></td><td>4</td><td>The current directory global depth</td></tr><tr><td><code>local_depths_</code></td><td>512</td><td>An array of bucket page local depths</td></tr><tr><td><code>bucket_page_ids_</code></td><td>2048</td><td>An array of bucket page ids</td></tr></tbody></table><p>难点在于<strong>分裂</strong>与<strong>合并</strong></p><ul><li>Global Depth：用几位来分类，这几位必须不同</li><li>Local Depth：相同的几位将会被分在同一个桶里</li></ul><p>e.g. GD&#x3D;3，LD&#x3D;2，则1000和1100被分到同一个桶，LD&lt;&#x3D;GD</p><p>如果扩容到LD&#x3D;3，则新的桶位置id是：0000和1000，一个加0，一个加上1&lt;&lt;(LD-1)即可</p><h4 id="Extendible-Hashing-Implementation"><a href="#Extendible-Hashing-Implementation" class="headerlink" title="Extendible Hashing Implementation"></a>Extendible Hashing Implementation</h4><p>一个Extendible Hash Table需要什么？</p><p>层层打开的Hash结构，注意对应的RWPageGuard</p><ul><li><p>Insert：插入新的dir和bucket。判断扩容，扩容时数据的迁移</p><p>new dir?使用newpage申请并升级</p></li><li><p>Remove：和insert一样都是基于bucket的函数操作，但是要注意shrink条件</p><p>bucket为空，LD&#x3D;&#x3D;GD（这个bucket不被需要了），递归进行：</p><p>DecLD，更新映射 dir-&gt;bucket ，移动原bucket</p></li><li><p>SplitBucket：</p></li></ul><h2 id="小狗屎后端"><a href="#小狗屎后端" class="headerlink" title="小狗屎后端"></a>小狗屎后端</h2>]]></content>
    
    
    
    <tags>
      
      <tag>项目</tag>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2025/03/01/Redis/"/>
    <url>/2025/03/01/Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>实现方式：</p><ul><li>AOF日志：Append Only File，执行一条写一条日志。所以是在写完日志之后，记录做过的事。AOF丢失少，恢复慢。</li><li>RDB快照：全量快照，影响性能。</li><li>混合方式：RDB负责前半全量数据，减少能耗、快速恢复。AOF负责后半增量数据。</li></ul><h3 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h3><p><em>由于网络问题产生多个Leader</em>，旧Leader写入数据被新Leader的同步清除了</p><p><strong>解决方案</strong></p><p>在可能发生故障时限制写入</p><p>节点数量&lt;N 或 通信时长&gt;T</p><h4 id="Extra-Money"><a href="#Extra-Money" class="headerlink" title="Extra Money"></a>Extra Money</h4><p><strong>跳表</strong></p><p>​很好地解释了什么是跳表，一个每次跳跃2^n的二维数组<img src="https://picx.zhimg.com/v2-be424e42c99fde208c835d565499c3d7_1440w.jpg" alt="img"></p><p>和平衡二叉树不同的是，跳表使用概率达成均衡。每个节点有1&#x2F;skip的概率添加至上一层。</p><p><strong>RedBlack Tree</strong></p><p><em>为什么Redis使用跳表而不是红黑树？</em></p><ul><li>实现难度，维护成本</li><li>查询高效</li><li>并发扩展</li><li>概率平衡&#x2F;严格平衡</li></ul><h2 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h2><p><strong>过期字典</strong>：给设置过期时间的Key放在里面，查询时优先查找Expire Dict，比对过期时间</p><p><strong>惰性删除+定期删除</strong></p><p>​访问时过期才删除</p><p>​随机抽取，看看过期的占比。如果占比过多则重复删除。否则仅删除一轮</p><p><strong>RDB淘汰策略</strong></p><ul><li>新的RDB文件生成时会淘汰</li><li>主服务器淘汰。从服务器不主动淘汰，除非主服务器同步清除（DEL指令）</li></ul><p><strong>AOF淘汰策略</strong></p><ul><li>写入时保留过期键，等其被删除再追加DEL指令</li><li>重写时淘汰过期键</li></ul><p><strong>LRU LFU</strong></p><h2 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h2><h3 id="缓存保护"><a href="#缓存保护" class="headerlink" title="缓存保护"></a>缓存保护</h3><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a><strong>缓存雪崩</strong></h4><p>缓存雪崩是指在某一时间段内，大量缓存数据<strong>同时失效</strong>或<strong>缓存系统宕机</strong>，导致所有请求直接涌向数据库，造成数据库瞬时压力激增甚至崩溃的现象。</p><p><strong>解决方案</strong></p><ol><li><strong>失效时间随机化</strong>：在基础过期时间上增加随机偏移值（如：基础300秒±随机120秒）</li><li><strong>分级缓存架构</strong>：采用L1&#x2F;L2缓存分级，L1设置短时间，L2设置长时间</li><li><strong>热点数据永不过期</strong>：配合异步更新机制维护数据一致性</li><li><strong>熔断降级机制</strong>：使用Hystrix或Sentinel实现请求限流</li><li><strong>集群高可用</strong>：Redis Cluster模式部署，保证单节点故障不影响整体服务</li></ol><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a><strong>缓存击穿</strong></h4><p>某个超高热点的缓存突然失效，导致<strong>海量请求直接冲击数据库</strong>，形成”单点爆破”效应。</p><p><strong>解决方案</strong></p><ul><li><p><strong>互斥锁（Mutex Lock）</strong>：仅允许一个线程通过查询重建缓存，其他线程等待后重试。</p><p><em>互斥锁仅针对数据库请求</em></p></li><li><p><strong>逻辑过期</strong>：缓存永不过期，但存储逻辑过期时间，由后台线程异步更新。</p></li><li><p><strong>缓存预热</strong>：在高峰前预先加载热点数据。</p></li></ul><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a><strong>缓存穿透</strong></h4><p>大量请求查询<strong>数据库中不存在的数据</strong>，导致缓存无法命中，请求直接穿透到数据库。</p><p><strong>解决方案</strong></p><ul><li><strong>空值缓存</strong>：对查询结果为null的键，缓存短TTL的空值（如 <code>redis.set(key, null, 60)</code>）。</li><li><strong>布隆过滤器（Bloom Filter）</strong>：在缓存层前加过滤器，快速拦截无效请求。</li><li><strong>参数校验</strong>：对请求参数进行格式、范围校验（如ID必须为正整数）。</li></ul><h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><ul><li><p>Catch Aside：优先改变数据库，然后更新缓存</p><p><em><strong>为什么先数据库后缓存？</strong></em></p><p>源数据不更改，缓存始终跟着走。而且更新缓存比数据库快多了</p></li><li><p>R&#x2F;W Through：仅和缓存交互。其余交给缓存组件（不常见）</p></li><li><p>Write Back：批量异步更新脏缓存，写得快，容易丢数据</p></li></ul><h2 id="实战！！！"><a href="#实战！！！" class="headerlink" title="实战！！！"></a>实战！！！</h2><h3 id="大Key问题"><a href="#大Key问题" class="headerlink" title="大Key问题"></a>大Key问题</h3><p><strong>Key的Value很大</strong></p><ul><li>客户端超时</li><li>网络阻塞</li><li>工作线程阻塞</li><li>内存分布不均</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库的锁</title>
    <link href="/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%94%81/"/>
    <url>/2025/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>让数据库变成read only</p><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><ol><li>表锁：给表加锁，同时本线程无法访问其他表</li><li>元数据锁：对表操作隐式使用</li><li>意向锁：行级锁之前，快速判断有无记录被加锁</li><li>AUTO-INC锁：用于自增类型的加锁，不然容易出错</li></ol><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><ol><li>Record Lock：锁记录</li><li>Gap Lock：锁范围（开区间）。间隙锁之间是兼容的的，可以由多个事务持有重复区间的间隙锁。</li><li>Next-Key Lock：记录锁+间隙锁（一开一闭）。既保护了当前记录，又阻止间隙之间有新值插入。</li><li>插入意向锁：用于插入时占用锁等待队列。</li></ol><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>一致性，有效性，防止脑裂-&gt;过半节点同意。</p><h3 id="基于Redis"><a href="#基于Redis" class="headerlink" title="基于Redis"></a>基于Redis</h3><p>设置一个公共的Key和对应过期时间。Key&#x3D;0可以获得锁，否则不行。</p><h2 id="加锁时机"><a href="#加锁时机" class="headerlink" title="加锁时机"></a>加锁时机</h2><p>select update…</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>两个事务获得了公共的间隙锁，但是插入意向锁和对方的间隙锁起了冲突。</p><p><strong>解决方案</strong></p><ol><li>降低隔离级别，RC就不会使用gap lock</li><li>使用唯一索引，避免全表扫描…</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>分布式系统</tag>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四种隔离级别的思考</title>
    <link href="/2025/02/26/Txn/"/>
    <url>/2025/02/26/Txn/</url>
    
    <content type="html"><![CDATA[<h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>整体分为：</p><ol><li>读未提交</li><li>读已提交</li><li>可重复读</li><li>串行化</li></ol><h2 id="可能产生的问题"><a href="#可能产生的问题" class="headerlink" title="可能产生的问题"></a>可能产生的问题</h2><ol><li>脏读：读到其他事务未提交的数据，容易理解</li><li>不可重复读：多次读同一行内容不一致</li><li>幻读：多次读某个范围的数据，范围不一致（有插入删除）</li></ol><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>脏读和不可重复度：脏读可以认为事务B单次读取数据，读到事务A修改但未提交的数据。不可重复读可以看作事务B在事务A修改前后分别读了一次，得到的数据自然不同。</p><p>不可重复读和幻读：不可重复读按照上述，主要冲突在一次事务内读同一行两次数据不同。幻读可以认为是事务B读取某一范围的数据，而事务A在B的两次读取之间对该范围插入或删除了数据。产生一次读2条，第二次读3条的错误。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>通过产生的原因可以想到对应解决办法</p><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>通过MVCC（读快照），避免读到其他事务做出的修改。</p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>MVCC给每个事务生成最新快照，避免事务之间互相影响。</p><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>MVCC无法拦住边读边写的幻读。当数据出现更新，会悄悄把更新数据加进来。因此需要间隙锁或临键锁。</p><ol><li>间隙锁：范围锁，比如查询age&gt;20，会锁住(20,+inf)阻隔新数据加入&#x2F;旧数据修改。</li><li>临键锁：范围+当前键，比如age&gt;20，可以得到[20,+inf)</li></ol><h2 id="为什么有四种"><a href="#为什么有四种" class="headerlink" title="为什么有四种"></a>为什么有四种</h2><p><strong>为什么有四种隔离级别？既然低级别会产生错误，直接上高级别一刀切不就好了？</strong></p><p>数据库性能与一致性的互相妥协。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>raft</title>
    <link href="/2025/02/24/raft/"/>
    <url>/2025/02/24/raft/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>这是一个测试</title>
    <link href="/2025/02/24/%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95/"/>
    <url>/2025/02/24/%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="这是一个测试"><a href="#这是一个测试" class="headerlink" title="这是一个测试"></a>这是一个测试</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="标题1"><a href="#标题1" class="headerlink" title="标题1"></a>标题1</h2><h3 id="标题2"><a href="#标题2" class="headerlink" title="标题2"></a>标题2</h3>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>测试1</tag>
      
      <tag>测试2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试</title>
    <link href="/2025/02/24/%E6%B5%8B%E8%AF%95/"/>
    <url>/2025/02/24/%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/02/24/hello-world/"/>
    <url>/2025/02/24/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
